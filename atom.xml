<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TrBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-19T04:06:18.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>tr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo配置</title>
    <link href="http://example.com/2022/01/19/hello-world/"/>
    <id>http://example.com/2022/01/19/hello-world/</id>
    <published>2022-01-19T07:07:36.261Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 迁移一些自己的服务</title>
    <link href="http://example.com/2022/01/18/Docker-%E8%BF%81%E7%A7%BB%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/01/18/Docker-%E8%BF%81%E7%A7%BB%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-01-18T11:07:00.000Z</published>
    <updated>2022-01-19T08:06:42.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迁移自己的服务"><a href="#迁移自己的服务" class="headerlink" title="迁移自己的服务"></a>迁移自己的服务</h1><blockquote><p>用docker把以前服务器上的一些服务打包推送到docker hub</p></blockquote><span id="more"></span><h2 id="博客-hexo"><a href="#博客-hexo" class="headerlink" title="博客 hexo"></a>博客 hexo</h2><blockquote><p>hexo是基于nodejs的，所以镜像基于node，以下是dockerfile</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">FROM node</span><br><span class="line"></span><br><span class="line">MAINTAINER tangrui&lt;1540525748@qq.com&gt;</span><br><span class="line"></span><br><span class="line">WORKDIR /home/hexo</span><br><span class="line"></span><br><span class="line">RUN npm install -g hexo-cli &amp;&amp; hexo init /home/hexo &amp;&amp; cd /home/hexo &amp;&amp; npm install &amp;&amp; npm install hexo-server --save</span><br><span class="line">RUN apt update &amp;&amp; apt install -y vim &amp;&amp; apt install -y unzip</span><br><span class="line">RUN npm install --save hexo-admin </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ADD https://codeload.github.com/MOIPA/MOIPA.github.io/zip/refs/heads/master /home/hexo/<span class="built_in">source</span>/public</span></span><br><span class="line">RUN [&quot;wget&quot;,&quot;https://codeload.github.com/MOIPA/MOIPA.github.io/zip/refs/heads/master&quot;,&quot;-O&quot;,&quot;./master&quot;]</span><br><span class="line"></span><br><span class="line">RUN unzip -oq ./master &amp;&amp; mkdir public</span><br><span class="line">RUN mv  MOIPA.github.io-master/* ./public</span><br><span class="line">RUN rm -rf MOIPA.github.io-master</span><br><span class="line"></span><br><span class="line">RUN git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;s/landscape/next/g&#x27; _config.yml</span><br><span class="line"></span><br><span class="line">RUN npm install hexo-migrator-rss --save</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置RSS订阅，提供订阅链接</span></span><br><span class="line">RUN [&quot;npm&quot;,&quot;install&quot;,&quot;hexo-generator-feed&quot;,&quot;--save&quot;]</span><br><span class="line"> </span><br><span class="line">RUN echo &quot;\n\</span><br><span class="line">Plugins:\n\</span><br><span class="line">- hexo-generate-feed\n&quot;\</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; _config.yml</span> </span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;s/#RSS/RSS/g&#x27; ./themes/next/_config.yml \</span><br><span class="line">&amp;&amp; sed -i &#x27;s/Muse/Gemini/g&#x27; ./themes/next/_config.yml &amp;&amp;\</span><br><span class="line">sed -i &#x27;s/url: #/url: /g&#x27; ./themes/next/_config.yml </span><br><span class="line"></span><br><span class="line">RUN hexo g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 4000 </span><br><span class="line"></span><br><span class="line">VOLUME [&quot;/home/hexo/&quot;]</span><br><span class="line"></span><br><span class="line">CMD [&quot;hexo&quot;,&quot;server&quot;,&quot;-p&quot;,&quot;4000&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>这个版本的hexo配置了next主题，我的git上的public的gitio博客内容，和rss迁移内容</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动博客容器</span></span><br><span class="line">docker run -d --name trhexo -p 5555:4000 moipa/hexo:1.4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 迁移所有博客</span></span><br><span class="line">docker exec -it trhexo /bin/bash</span><br><span class="line"></span><br><span class="line">hexo migrate rss http://39.108.159.175:4000/atom.xml</span><br></pre></td></tr></table></figure><h1 id="配置个人的专属hexo镜像"><a href="#配置个人的专属hexo镜像" class="headerlink" title="配置个人的专属hexo镜像"></a>配置个人的专属hexo镜像</h1><ol><li><p>将linux的公钥私钥复制到镜像中</p></li><li><p>将source/_posts文件夹改为git目录，文档从github上同步，在deploy脚本内写好git push的命令</p></li><li><p>每次新电脑只需要<code>docker pull moipa/hexo:2.x</code>到本地运行即可</p></li><li><p>生成了hexo admin的key，再次使用的时候可能需要注释掉，重新去admin界面生成</p></li><li><p>自动同步（图片和文档）git脚本写好了，可以在配置好admin界面后将这个脚本加上去，之后只需要点击deploy即可完成部署<br><img src="/images/pasted-129.png" alt="upload successful"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;迁移自己的服务&quot;&gt;&lt;a href=&quot;#迁移自己的服务&quot; class=&quot;headerlink&quot; title=&quot;迁移自己的服务&quot;&gt;&lt;/a&gt;迁移自己的服务&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用docker把以前服务器上的一些服务打包推送到docker hub&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra迪杰斯特拉算法</title>
    <link href="http://example.com/2021/10/29/Dijkstra%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/10/29/Dijkstra%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-29T14:42:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra迪杰斯特拉算法"><a href="#Dijkstra迪杰斯特拉算法" class="headerlink" title="Dijkstra迪杰斯特拉算法"></a>Dijkstra迪杰斯特拉算法</h1><p>最短路径算法</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>个人感觉迪杰斯特拉算法和普利姆(Prime)算法很像都是从已有集合找到最小边开始，向集合内持续添加最小边的节点。首先写出所有节点的直接路径，从已有集合开始算到其他节点的最短距离，将在这一轮中找到的最小距离所在的节点录入集合，循环……</p><h2 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h2><p><img src="/images/pasted-90.png" alt="upload successful"><br>以这个为例我们找出节点1到其他所有节点的最短距离</p><p><img src="/images/pasted-91.png" alt="upload successful"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">画出整张表格的框架，顶点 2，3，4，5 初始集合为1，第一轮查看1到2，3，4，5的距离分别为10，无穷，无穷，5。找出第一轮的最短距离为 1-5的距离，将5加入集合。之后再也不用关注5，因为已经是最短距离了（不存在经过其他节点更小的情况，可以自行推算）。</span><br><span class="line"></span><br><span class="line">第一轮结束后，集合内有1，5两个节点，且5节点不用再关注了，第二轮开始：看刚刚假如的节点5到其他节点的距离再加上1-5的距离，看是否小于左边的距离，小的话就替换，5到2，3，4的距离分别为3，9，2，加上1到5的距离后为：8，14，7都比左边一列小，所以结果都覆写了，再次找到最小距离：1-5-4的距离7，将4假如集合。</span><br><span class="line"></span><br><span class="line">循环到所有节点进入集合即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下次实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dijkstra迪杰斯特拉算法&quot;&gt;&lt;a href=&quot;#Dijkstra迪杰斯特拉算法&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra迪杰斯特拉算法&quot;&gt;&lt;/a&gt;Dijkstra迪杰斯特拉算法&lt;/h1&gt;&lt;p&gt;最短路径算法&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Floyd最短路径算法</title>
    <link href="http://example.com/2021/10/29/Floyd%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/10/29/Floyd%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-29T11:35:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FLOYD-最短路径算法"><a href="#FLOYD-最短路径算法" class="headerlink" title="FLOYD 最短路径算法"></a>FLOYD 最短路径算法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>佛洛依德最短路径实际上是使用了两个邻接矩阵遍历完成的 O(n^3)，一个邻接矩阵A用来保存点到点的路径权重，另一个B用来保存路径。</p><p>A的初始已经写好了点到点的直接距离，对于没有直连的点，内容都算作无穷。然后依次取中间点后再依次遍历通过这个中间点的距离，如果小于原来的A矩阵的内的距离，那么就覆写且将路径写入B矩阵。</p><h2 id="图解例子"><a href="#图解例子" class="headerlink" title="图解例子"></a>图解例子</h2><p><img src="/images/pasted-86.png" alt="upload successful"></p><p>根据这个图做两个矩阵A（存储点到点的距离），B（存储经过点）</p><p><img src="/images/pasted-87.png" alt="upload successful"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上图为例，录入后的矩阵A，A[0][1]表示0节点到1节点的距离为5，A[1][0]就表示节点1到节点0的距离，无穷表示无法连接。</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-88.png" alt="upload successful"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路径Path，对于B[0][1]表示 0节点到1节点需要经过什么节点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现在开始从头遍历，先找出节点对（就是图中什么节点可以到什么节点）有：</span><br><span class="line"></span><br><span class="line">&lt;0,1&gt; &lt;0,2&gt; &lt;0,3&gt;</span><br><span class="line">&lt;1,0&gt; &lt;1,2&gt; &lt;1,3&gt;</span><br><span class="line">&lt;2,0&gt; &lt;2,1&gt; &lt;2,3&gt;</span><br><span class="line">&lt;3,0&gt; &lt;3,1&gt; &lt;3,2&gt;</span><br><span class="line"></span><br><span class="line">现在取中间节点0（挨个取0，1，2，3）:对于0节点来说0节点到某节点距离，使用0作为中间节点是无意义的，所以包含0节点的节点对都不看，从&lt;1,2&gt;开始，即1使用0节点作为中间节点到2 = 1到0的节点距离+ 0到2的节点距离，也就是 A[1,2] = A[1,0] + A[0,2]。如果这个距离是小于原来距离的那么就更新，这里4&gt;无穷所以不更新。</span><br><span class="line"></span><br><span class="line">每次算可能有点绕，这里有个技巧：假设还是算 A[1,2]以 X 作为中间节点，可以先找到 A[1,2]在图中的点，分别朝着两个 X 方向走（X 行和 X 列），看他们的和是否小于自己，小于就更新自己，且在B矩阵内更新B[1,2] = X。这里X可以是0，1，2，3节点。</span><br></pre></td></tr></table></figure><p>如此遍历更新两个矩阵得到最后结果：</p><p><img src="/images/pasted-89.png" alt="upload successful"></p><h2 id="查找代码实现"><a href="#查找代码实现" class="headerlink" title="查找代码实现"></a>查找代码实现</h2><p>现在我们得到了最后的更新结果，使用的话以<code>A[1][0]</code>为例，即1节点到0节点从A矩阵可以看到1节点到0节点距离6，根据Path矩阵，看到<code>Path[1][0] = 3</code>表示 1到0节点要经过3，再看1到3和3到0，<code>Path[1][3] = -1</code>表示1到3直连，查<code>Path[3][0] = 2</code> 表示3到0经过节点2，查看3-2和2-0结果是-1，所以最后路径是<code>1-3-2-0</code>，不难发现这个过程是递归的，代码实现较为简单如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印节点x到节点y 经过的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matrixPath 邻接矩阵的路径矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> matrixPath[][])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrixPath[x][y] == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1表示直连 输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;直连&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要经过一个节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;经过节点:&quot;</span> + matrixPath[x][y]);</span><br><span class="line">        <span class="comment">// 递归查找x与y到中间节点的中间节点</span></span><br><span class="line">        printPath(x, matrixPath[x][y], matrixPath);</span><br><span class="line">        printPath(matrixPath[x][y], y, matrixPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径实现"><a href="#最短路径实现" class="headerlink" title="最短路径实现"></a>最短路径实现</h2><p>再看一下最短路径的过程会发现本质就是遍历更新两个表，从选取中间节点开始遍历，找到中间节点后遍历所有节点，对比节点的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成最短路径矩阵</span></span><br><span class="line"><span class="comment"> * 传入的矩阵都是方阵 即长宽一样的多维数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matrix     图的邻接矩阵表示，传入时已经写好了点到点的直接距离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matrixPath 图的路径矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floydGenerate</span><span class="params">(<span class="keyword">int</span> matrix[][], <span class="keyword">int</span> matrixPath[][])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化路径矩阵 -1表示直连 一开始所有点都算做直连，matrix保存了直连的距离，如果两个节点不能直连，那么算作距离无限大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrixPath.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrixPath.length; j++) &#123;</span><br><span class="line">            matrixPath[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选取中间经过节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> passingByNode = <span class="number">0</span>; passingByNode &lt; matrix.length; passingByNode++)</span><br><span class="line">        <span class="comment">// 选取节点对(开始节点和结束节点) 0-1 0-2 0-3 ...这样的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> startNode = <span class="number">0</span>; startNode &lt; matrix.length; startNode++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> endNode = <span class="number">0</span>; endNode &lt; matrix.length; endNode++)</span><br><span class="line">                <span class="comment">// 计算开始节点到经过节点的值和经过节点到结束节点的值</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[startNode][passingByNode] + matrix[passingByNode][endNode] &lt; matrix[startNode][endNode]) &#123;</span><br><span class="line">                    matrix[startNode][endNode] = matrix[startNode][passingByNode] + matrix[passingByNode][endNode];</span><br><span class="line">                    matrixPath[startNode][endNode] = passingByNode;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;FLOYD-最短路径算法&quot;&gt;&lt;a href=&quot;#FLOYD-最短路径算法&quot; class=&quot;headerlink&quot; title=&quot;FLOYD 最短路径算法&quot;&gt;&lt;/a&gt;FLOYD 最短路径算法&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ArchLinux滚挂的一次修复</title>
    <link href="http://example.com/2021/09/11/ArchLinux%E6%BB%9A%E6%8C%82%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8D/"/>
    <id>http://example.com/2021/09/11/ArchLinux%E6%BB%9A%E6%8C%82%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BF%AE%E5%A4%8D/</id>
    <published>2021-09-11T18:21:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的Arch一年没更新-滚挂了"><a href="#我的Arch一年没更新-滚挂了" class="headerlink" title="我的Arch一年没更新 滚挂了"></a>我的Arch一年没更新 滚挂了</h1><p>事情是这样的：好久没用另一台电脑，登入系统的时候打开chrome想更新下插件，好死不死的退了google账号，想重新登入的，发现google账号被疯狂登出，整了一个小时才发现是chrome的问题（我是弱智）。我用的是chrome的开源版：chromium，自从21年2月份开始google的登陆api收紧了政策，只有chrome可以登陆google账号。</p><p>一开始不知道这个政策，以为是chromiu的版本问题，事发的版本是83，我用pacman upgrade了下到了93的版本，启动chromium的时候提示动态链接库缺失。</p><p>这个问题其实我是知道的，因为arch的版本更新政策比较激进，可能半个月就更新了一次，且大部分上游的软件都依赖这些最新的库，所以如果是老系统更新新软件很容易出现动态链接库的问题，我本来也没在意，pacman -F 查了下软件包的依赖库，打算更新下以来。</p><p>但是！ 问题就出在了更新依赖库，我更新了一个底层依赖库 <code>icu</code>，导致我reboot的时候gnome-shell这些依赖老版本库的应用都无法启动了，只能进tty看了<code>alt + ctrl +3</code></p><p>回退也很麻烦我都忘了刚刚的icu是啥版本了，还更新几个其他的库，这样看来，只能全盘更新了，但是全盘更新估计也是出问题的。原因一个是我的系统太久没更新了一年了，版本跨太大还不知道有啥bug。其次我的内核是自定义的用了签名机制，如果内核更新了，原来的内核哈希码肯定对应不上新的内核，必定失败的。没办法，怀着忐忑的心情 <code>sudo pacman -Syu</code>了</p><p>嗯   果然挂了</p><h2 id="shim-签名问题"><a href="#shim-签名问题" class="headerlink" title="shim 签名问题"></a>shim 签名问题</h2><p>因为的内核是自定义编译的内核，比较适配我的surface硬件，为了美观开了secureboot，不然每次开机上面红色的锁的刺眼ui真的难受。secureboot是微软的一个机制，微软信任windows系统和几个第三放的bootloader（内核加载器）。这几个内核加载器呢需要我来指定内核，怎么指定呢，用shim签名（哈希）来做这件事。</p><p>举例：我的编译好的新内核，我用shim签名生成了哈希结果，我需要再下一次开机启动是enroll，引入这个签名，这样secureboot启动bootloader，bootlaoder查看自己的信任列表，有这个内核，可以启动。</p><p>签好名后还需要重新编写启动的配置文件，因为需要指定内核，真麻烦</p><h2 id="重新配置内核引导"><a href="#重新配置内核引导" class="headerlink" title="重新配置内核引导"></a>重新配置内核引导</h2><p>arch的livecd在做，家里突然没网了，下次整</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我的Arch一年没更新-滚挂了&quot;&gt;&lt;a href=&quot;#我的Arch一年没更新-滚挂了&quot; class=&quot;headerlink&quot; title=&quot;我的Arch一年没更新 滚挂了&quot;&gt;&lt;/a&gt;我的Arch一年没更新 滚挂了&lt;/h1&gt;&lt;p&gt;事情是这样的：好久没用另一台电脑，登</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DNF私服搭建</title>
    <link href="http://example.com/2021/09/11/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/09/11/DNF%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</id>
    <published>2021-09-11T17:36:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="毒奶粉私服配置"><a href="#毒奶粉私服配置" class="headerlink" title="毒奶粉私服配置"></a>毒奶粉私服配置</h1><blockquote><blockquote><p>偶然刷b站发现了毒奶粉的单机教学视频，突然儿时日日通宵打dnf的回忆涌上脑海，搜了下网上的配置，找了个比较纯净的版本</p></blockquote></blockquote><h2 id="服务端文件"><a href="#服务端文件" class="headerlink" title="服务端文件"></a>服务端文件</h2><blockquote><blockquote><p>我原以为是dnf的源代码被泄露了，其实只是服务端代码被泄露了，代码是台服的70版本，网上的魔改也是照这个版本改的</p></blockquote></blockquote><blockquote><blockquote><p>在贴吧的资源里可以找到配置教程，所使用的环境是centos 5-7。打包好了资源文件和安装脚本，比较遗憾的是我不太想用centos，还是那么老的版本，如果能把服务docker化方便迁移是最好的</p></blockquote></blockquote><p><img src="/images/pasted-82.png" alt="upload successful"></p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol><li><p>按照百度贴吧的教程，上传到root目录下，<code>dof.tar.gz</code>和脚本文件<code>dof</code>，dof是个安装环境的shell脚本，看了下脚本没有装什么奇怪的东西。</p></li><li><p><code>chmod +x dof</code>,<code>./dof</code>执行完毕脚本即可</p></li><li><p><code>dof.tar.gz</code> 这里面是服务端php文件，会被解压到<code>/home/neople</code>目录下，大部分的ip配置都在里面如果需要替换ip 如下指令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将这个目录下所有cfg结尾的，里面含有ip的内容的文件列出，替换里面内容</span><br><span class="line">sed -i &quot;s/stun_ip=/stun_ip=172.17.0.1/g&quot; `grep ip -rl /home/neople/game/cfg/*.cfg`</span><br></pre></td></tr></table></figure></li></ol><h3 id="上云的问题"><a href="#上云的问题" class="headerlink" title="上云的问题"></a>上云的问题</h3><blockquote><blockquote><p>上面人家给的脚本和配置只是针对单个虚拟机或者centos云的情况，如果是云的话还需要开放对应端口，可以下周<code>nmap</code>扫描工具，<code>nmap 127.0.0.1</code> 把里面的端口开放下即可</p></blockquote></blockquote><p><img src="/images/pasted-83.png" alt="upload successful"></p><blockquote><blockquote><p>更换ip的问题，这个脚本里面实际会自动检测服务器当前的ip，让tcp绑定这个ip，不过如果是虚拟机没有配置好nat或者上云要手动输入公网ip的话，可以将dof解压的目录的ip替换下</p></blockquote></blockquote><p><img src="/images/pasted-84.png" alt="upload successful"></p><h3 id="docker的探索-（linux下，windows一样只不过映射目录换下：-d-…"><a href="#docker的探索-（linux下，windows一样只不过映射目录换下：-d-…" class="headerlink" title="docker的探索 （linux下，windows一样只不过映射目录换下：/d/…)"></a>docker的探索 （linux下，windows一样只不过映射目录换下：/d/…)</h3><ol><li><code>docker pull centos:7</code>:下载centos7的话用这个，记住跑这个镜像的时候最好开启真正的虚拟机环境，因为docker的虚拟实质上是单个独立应用线程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --net=host -p 3360:3360 -v /root/dnfServer:/root centos:7 /usr/sbin/init --privileged=true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>--privileged=true</code>:真正开启root，否则docker里面的root只是个普通用户<br><code>-v /root/dnfServer:/root</code>:映射下文件，不然没法传安装文件和脚本<br><code>/usr/sbin/init</code>: 启动容器之后可以使用systemctl方法<br><code>-p 3360:3360</code>: 映射下端口，先映射个数据库的，实际上如果host模式不需要映射了</p><ol start="2"><li>如果你要使用centos5，那么命令需要改下</li></ol><p><code>docker run -itd --privileged=true --net=host -p 3360:3360 -v /root/dnfServer:/root centos:5 /sbin/init </code><br>这是因为centos5的init不在usr目录下，至于为什么需要加上<code>/sbin/init</code> 这是为了使用systemctl命令，不然 1号进程不是 init的话系统会缺失很多信息</p><ol start="3"><li><p>生成并且运行容器后可以查看下：<code>docker ps -a</code></p></li><li><p>将dof和dof.tar.gz存入/root/dnfServer中，然后进入容器<code>docker exec -it &lt;你的容器id&gt; /bin/bash</code></p></li><li><p>进入后记得cp命令将文件拷贝到/目录下，然后执行dof脚本即可</p></li></ol><h3 id="docker的时候遇到的问题"><a href="#docker的时候遇到的问题" class="headerlink" title="docker的时候遇到的问题"></a>docker的时候遇到的问题</h3><blockquote><blockquote><p>很奇怪的事是告诉我确实类库，libstd，查了下这个是gcc的动态链接库，没办法，我用的还是centos5 最老的一个版本，已经不再支持更新，yum源换了也没啥用，直接去官网下载离线包，离线安装了，centos5的包地址是<code>ult.centos.org/5.11/os/x86_64/</code> 我的版本是5.11 其他版本自行替换，ctrl+f找到gcc，glibc相关的包，下载下来上传到服务器，然后安装：<code>rpm -Uvh xxxx.rpm --nodeps</code></p></blockquote></blockquote><blockquote><blockquote><p>去容器的home目录下执行run脚本即可，然后启动游戏享受吧</p></blockquote></blockquote><h2 id="docker-的网络模式"><a href="#docker-的网络模式" class="headerlink" title="docker 的网络模式"></a>docker 的网络模式</h2><p>本来在docker安装前我担心这个ip映射的问题，我在想是不是要用bridge模式，制造虚拟网卡，让宿主机和容器互通，这部分有点麻烦，配置完后游戏的客户端需要连接云的公网ip，然后再做个映射。后来发现大可不必，直接host模式就好了，所有服务端口就开在宿主机上o了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>docker真是个好东东，这下以后服务器没了，直接把容器拷贝过去start一下就好了，多舒服，docker仓库+1。</p><p>dnf是个好游戏，但是已经不再是儿时的act动作游戏了，她已经变质了，不再可能有白板装备技术流单刷老牛的情况了，从70版本男法出现后dnf就是个二次元动画rpg快餐游戏了，纪念逝去的青春。</p><p><img src="/images/pasted-85.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;毒奶粉私服配置&quot;&gt;&lt;a href=&quot;#毒奶粉私服配置&quot; class=&quot;headerlink&quot; title=&quot;毒奶粉私服配置&quot;&gt;&lt;/a&gt;毒奶粉私服配置&lt;/h1&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;偶然刷b站发现了毒奶粉的单机教学视频，突然儿时日</summary>
      
    
    
    
    
    <category term="DNF" scheme="http://example.com/tags/DNF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题11 动规</title>
    <link href="http://example.com/2021/06/23/LeetCode-%E6%AF%8F%E6%AC%A1%E4%B8%89%E9%81%93%E9%A2%9811-%E5%8A%A8%E8%A7%84/"/>
    <id>http://example.com/2021/06/23/LeetCode-%E6%AF%8F%E6%AC%A1%E4%B8%89%E9%81%93%E9%A2%9811-%E5%8A%A8%E8%A7%84/</id>
    <published>2021-06-23T10:20:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h1><p>medium 经典入门dp问题 一次ac</p><pre><code> * 计算三角形中每行最小值组成的路径 实际也是个经典的dp问题，从低到上 *    2 *   3 4 *  6 5 7 * 4 1 8 3 * * 从最底层开始：4，1，8，3 往上分别为 （10，7），（6，13），（15，10） 选出最小的7，6，10 * 继续：9，10  最后：11</code></pre><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算三角形中每行最小值组成的路径 实际也是个经典的dp问题，从低到上</span></span><br><span class="line"><span class="comment">     *    2</span></span><br><span class="line"><span class="comment">     *   3 4</span></span><br><span class="line"><span class="comment">     *  6 5 7</span></span><br><span class="line"><span class="comment">     * 4 1 8 3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 从最底层开始：4，1，8，3 往上分别为 （10，7），（6，13），（15，10） 选出最小的7，6，10</span></span><br><span class="line"><span class="comment">     * 继续：9，10  最后：11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            return triangle.stream().map(x -&gt; x.stream().min(Comparator.comparingInt(n -&gt; n))).mapToInt(Optional::get).sum();</span></span><br><span class="line">            <span class="keyword">int</span>[] costs = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.get(triangle.size() - <span class="number">1</span>).size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triangle.get(triangle.size() - <span class="number">1</span>).size(); i++)</span><br><span class="line">                costs[i] = triangle.get(triangle.size() - <span class="number">1</span>).get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; triangle.get(i).size(); j++)</span><br><span class="line">                    costs[j] = Math.min(costs[j] + triangle.get(i).get(j), costs[j + <span class="number">1</span>] + triangle.get(i).get(j));</span><br><span class="line">            <span class="keyword">return</span> costs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h1><p><img src="/images/pasted-77.png" alt="upload successful"></p><p><img src="/images/pasted-78.png" alt="upload successful"><br>easy 差值最大 o（n)复杂度的算法不太容易想得到，具体问题具体分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 暴力算法  o(n^2)</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> prices</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;prices.length; j++) &#123;</span><br><span class="line">                   max = Math.max(prices[j] - prices[i], max);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 牛逼算法  o(n)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> lowest = prices[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (prices[i]&gt;lowest) max = Math.max(max, prices[i] - lowest);</span><br><span class="line">               <span class="keyword">else</span> lowest = prices[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> max;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="Best-Time-to-Buy-and-Sell-Stock-II-122"><a href="#Best-Time-to-Buy-and-Sell-Stock-II-122" class="headerlink" title="Best Time to Buy and Sell Stock II 122"></a>Best Time to Buy and Sell Stock II 122</h1><p>上题的变种，这次可以多次买入卖出，这题真……，想得到的话简单的不行，想不到的话……，最重要的是画成图看规律</p><p><img src="/images/pasted-79.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这题不应该是easy  很难想到这个算法和规律</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 第一个解法： 实际有个规律，就是所有的邻近高点-邻近低点的和 总是最大的！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> lowest;</span><br><span class="line">           <span class="keyword">int</span> highest;</span><br><span class="line">           <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">// 找到最低点</span></span><br><span class="line">               <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>]) i++;</span><br><span class="line">               lowest = prices[i];</span><br><span class="line">               <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>]) i++;</span><br><span class="line">               highest = prices[i];</span><br><span class="line">               maxProfit += highest - lowest;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> maxProfit;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 牛逼算法  画成图实际所有的收益 不过是所有的上坡的和</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> prices</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (prices[i]&lt;prices[i+<span class="number">1</span>]) max += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> max;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="Best-Time-to-Buy-and-Sell-Stock-III-123"><a href="#Best-Time-to-Buy-and-Sell-Stock-III-123" class="headerlink" title="Best Time to Buy and Sell Stock III 123"></a>Best Time to Buy and Sell Stock III 123</h1><p>佛了 改改题目还能变成dp问题，在上一题的基础上添加限制条件：只能有两次买卖操作</p><p>第一种思路：</p><p><img src="/images/pasted-80.png" alt="upload successful"></p><p>从最后一天开始：0，0.<br>倒数第二天：第一次最佳买入能赚3元<br>倒数第三天：第一次最佳买入赚1元，还没3元多，变为3元<br>倒数第四天：0-3一次+3的最大值=3，两次操作最大值=6，单次操作最大值4<br>…..</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span>[][] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][prices.length];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = prices.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span> (j &lt; prices.length) &#123;</span><br><span class="line">                   <span class="keyword">while</span> (j &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[j] &lt; prices[j + <span class="number">1</span>]) j++;</span><br><span class="line">                   <span class="keyword">if</span> (prices[j] - prices[i] &gt; record[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                       record[<span class="number">0</span>][i] = prices[j] - prices[i];</span><br><span class="line">                       <span class="comment">// 算第二次操作</span></span><br><span class="line">                       <span class="keyword">if</span> (j &lt; prices.length - <span class="number">1</span>) &#123;</span><br><span class="line">                           record[<span class="number">1</span>][i] = Math.max(record[<span class="number">1</span>][i], record[<span class="number">0</span>][j + <span class="number">1</span>] + record[<span class="number">0</span>][i]);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   j++;</span><br><span class="line">               &#125;</span><br><span class="line">               record[<span class="number">0</span>][i] = Math.max(record[<span class="number">0</span>][i], record[<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">               record[<span class="number">1</span>][i] = Math.max(record[<span class="number">1</span>][i], record[<span class="number">1</span>][i + <span class="number">1</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> Math.max(record[<span class="number">0</span>][<span class="number">0</span>], record[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-81.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//进行初始化，第一天 s1 将股票买入，其他状态全部初始化为最小值</span></span><br><span class="line">    <span class="keyword">int</span> s1=-prices[<span class="number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();++i) &#123;            </span><br><span class="line">        s1 = max(s1, -prices[i]); <span class="comment">//买入价格更低的股</span></span><br><span class="line">        s2 = max(s2, s1+prices[i]); <span class="comment">//卖出当前股，或者不操作</span></span><br><span class="line">        s3 = max(s3, s2-prices[i]); <span class="comment">//第二次买入，或者不操作</span></span><br><span class="line">        s4 = max(s4, s3+prices[i]); <span class="comment">//第二次卖出，或者不操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Triangle&quot;&gt;&lt;a href=&quot;#Triangle&quot; class=&quot;headerlink&quot; title=&quot;Triangle&quot;&gt;&lt;/a&gt;Triangle&lt;/h1&gt;&lt;p&gt;medium 经典入门dp问题 一次ac&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * 计算三角形中每行最小值组成的路径 实际也是个经典的dp问题，从低到上
 *    2
 *   3 4
 *  6 5 7
 * 4 1 8 3
 *
 * 从最底层开始：4，1，8，3 往上分别为 （10，7），（6，13），（15，10） 选出最小的7，6，10
 * 继续：9，10  最后：11
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Dp" scheme="http://example.com/tags/Dp/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题10 tree</title>
    <link href="http://example.com/2021/06/21/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9810-tree/"/>
    <id>http://example.com/2021/06/21/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9810-tree/</id>
    <published>2021-06-21T11:38:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="Construct Binary Tree from Inorder and Postorder Traversal"></a>Construct Binary Tree from Inorder and Postorder Traversal</h1><p><img src="/images/pasted-76.png" alt="upload successful"><br>106 同 105一样 同样规则构建树，只不过计算左右集合时需要注意下！ 55%</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTreefromPostorderandInorderTraversal106</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> Solution().buildTree(</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">3</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同105 用中序和后序构造树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> constructTree(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructTree</span><span class="params">(<span class="keyword">int</span>[] posOrder, <span class="keyword">int</span> posS, <span class="keyword">int</span> posE, <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> inS, <span class="keyword">int</span> inE)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 无遍历结果</span></span><br><span class="line">            <span class="keyword">if</span> (posS &gt; posE || inS &gt; inE) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (posS == posE) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(posOrder[posE]);</span><br><span class="line">            <span class="comment">// 找到根节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(posOrder[posE]);</span><br><span class="line">            <span class="comment">// 找到中序遍历的左边和右边两个集合</span></span><br><span class="line">            <span class="keyword">int</span> rootPosi;</span><br><span class="line">            <span class="keyword">for</span> (rootPosi = inS; rootPosi &lt;= inE; rootPosi++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root.val == inOrder[rootPosi]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> leftTreeLen = rootPosi - inS;</span><br><span class="line">            root.left = constructTree(posOrder, posS, posS + leftTreeLen - <span class="number">1</span>, inOrder, inS, rootPosi - <span class="number">1</span>);</span><br><span class="line">            root.right = constructTree(posOrder, posS + leftTreeLen, posE - <span class="number">1</span>, inOrder, rootPosi + <span class="number">1</span>, inE);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Pascal’s-Triangle-118"><a href="#Pascal’s-Triangle-118" class="headerlink" title="Pascal’s Triangle 118"></a>Pascal’s Triangle 118</h1><p>easy 帕斯卡三角形</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalTriangle118</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().generate(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 帕斯卡三角形</span></span><br><span class="line"><span class="comment">     *      1</span></span><br><span class="line"><span class="comment">     *    1   1</span></span><br><span class="line"><span class="comment">     *   1  2  1</span></span><br><span class="line"><span class="comment">     *  1 3   3  1</span></span><br><span class="line"><span class="comment">     * 1 4  6   4  1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; tmp = Arrays.asList(<span class="number">1</span>);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; curr = <span class="keyword">new</span> LinkedList();</span><br><span class="line">                curr.add(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tmp.size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    curr.add(tmp.get(j)+tmp.get(j+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                curr.add(<span class="number">1</span>);</span><br><span class="line">                tmp = curr;</span><br><span class="line">                res.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Pascal’s-TriangleII-119"><a href="#Pascal’s-TriangleII-119" class="headerlink" title="Pascal’s TriangleII 119"></a>Pascal’s TriangleII 119</h1><p>和上题一样 只不过只需要输出最上层，这个是o(k)的c++算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(rowIndex+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;rowIndex+<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">1</span>; j--)</span><br><span class="line">                A[j] += A[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal&quot;&gt;&lt;a href=&quot;#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal&quot; class=&quot;headerlink&quot; title=&quot;Construct Binary Tree from Inorder and Postorder Traversal&quot;&gt;&lt;/a&gt;Construct Binary Tree from Inorder and Postorder Traversal&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-76.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;106 同 105一样 同样规则构建树，只不过计算左右集合时需要注意下！ 55%&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题09 array</title>
    <link href="http://example.com/2021/06/20/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9809-array/"/>
    <id>http://example.com/2021/06/20/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9809-array/</id>
    <published>2021-06-20T13:12:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MaximalRectangle"><a href="#MaximalRectangle" class="headerlink" title="MaximalRectangle"></a>MaximalRectangle</h1><p>dp思路：和上一题一样 84， 转换下就好</p><p>上一题的84题我实际用了递归和dp和这题不一样，这里的思路是：每个柱子的面积都是<code>长度*高度</code>，这个长度就是<code>柱子右边的第一个小于柱子高度的柱子  -  柱子左边的第一个小于柱子高度的柱子 - 1</code>，因此主要点在算长度。</p><p>这题的dp思想体现在算宽度，每层宽度可以通过上层算出。    </p><p><img src="/images/pasted-72.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle2</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思路： 和84题一样</span></span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(left, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(right, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(height, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur_left = <span class="number">0</span>, cur_right = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// compute height (can do this from either side)</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) height[j]++;</span><br><span class="line">                <span class="keyword">else</span> height[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// compute left (from left to right)</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) left[j] = Math.max(left[j], cur_left);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    left[j] = <span class="number">0</span>;</span><br><span class="line">                    cur_left = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// compute right (from right to left)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) right[j] = Math.min(right[j], cur_right);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    right[j] = n;</span><br><span class="line">                    cur_right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// compute the area of rectangle (can do this from either side)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                maxA = Math.max(maxA, (right[j] - left[j]) * height[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="merge-sorted-array-o-m-n"><a href="#merge-sorted-array-o-m-n" class="headerlink" title="merge sorted array  o(m+n)"></a>merge sorted array  o(m+n)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray88</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().merge(a, <span class="number">5</span>, b, <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：把前m个数放到nums1后面m个上，前面m个当作空的用来存放结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">                    nums1[i] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                nums1[<span class="number">0</span>] = nums2[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不开辟多余空间的写法且速度为 o(m+n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                nums1[i + nums1.length - m] = nums1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> p1 = nums1.length - m;</span><br><span class="line">            <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pres = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (pres &lt; nums1.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p1 == nums1.length) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; p2 &lt; n; p2++) &#123;</span><br><span class="line">                        nums1[pres++] = nums2[p2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) nums1[pres++] = nums1[p1++];</span><br><span class="line">                    <span class="keyword">else</span> nums1[pres++] = nums2[p2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pres = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p1 == m) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; p2 &lt; n; p2++) &#123;</span><br><span class="line">                        res[pres++] = nums2[p2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; p1 &lt; m; p1++) &#123;</span><br><span class="line">                        res[pres++] = nums1[p1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) res[pres++] = nums1[p1++];</span><br><span class="line">                    <span class="keyword">else</span> res[pres++] = nums2[p2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Construct-BinaryTree-from-Preorder-and-Inorder-Traversal"><a href="#Construct-BinaryTree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="Construct BinaryTree from Preorder and Inorder Traversal"></a>Construct BinaryTree from Preorder and Inorder Traversal</h1><p>不难<br><img src="/images/pasted-75.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructBinaryTreefromPreorderandInorderTraversal105</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> Solution().buildTree(</span><br><span class="line">                <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> constructTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> preOrder 前序遍历结果</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> preS     结果开始下标</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> preE     结果结束下标</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> inOrder</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> inS</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> inE</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> preS, <span class="keyword">int</span> preE, <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> inS, <span class="keyword">int</span> inE)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 无遍历结果</span></span><br><span class="line">            <span class="keyword">if</span> (preS &gt; preE || inS &gt; inE) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (preS == preE) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preOrder[preS]);</span><br><span class="line">            <span class="comment">// 找到根节点</span></span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preOrder[preS]);</span><br><span class="line">            <span class="comment">// 找到中序遍历的左边和右边两个集合</span></span><br><span class="line">            <span class="keyword">int</span> rootPosi;</span><br><span class="line">            <span class="keyword">for</span> (rootPosi = inS; rootPosi &lt;= inE; rootPosi++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root.val == inOrder[rootPosi]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到前序遍历的左右两个集合</span></span><br><span class="line"><span class="comment">//            int preEnd;</span></span><br><span class="line"><span class="comment">//            for (preEnd = preS + 1; preEnd &lt;= preE; preEnd++) &#123;</span></span><br><span class="line"><span class="comment">//                // 判断是否在左集合内</span></span><br><span class="line"><span class="comment">//                boolean ifContains = false;</span></span><br><span class="line"><span class="comment">//                for (int i = inS; i &lt;= rootPosi - 1; i++) &#123;</span></span><br><span class="line"><span class="comment">//                    if (inOrder[i] == preOrder[preEnd]) ifContains = true;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                if (!ifContains) &#123;</span></span><br><span class="line"><span class="comment">//                    break;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            preEnd--;</span></span><br><span class="line">            <span class="keyword">int</span> leftTreeLen = rootPosi-inS;</span><br><span class="line">            root.left = constructTree(preOrder, preS + <span class="number">1</span>, preS+leftTreeLen, inOrder, inS, rootPosi - <span class="number">1</span>);</span><br><span class="line">            root.right = constructTree(preOrder, preS+leftTreeLen + <span class="number">1</span>, preE, inOrder, rootPosi + <span class="number">1</span>, inE);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MaximalRectangle&quot;&gt;&lt;a href=&quot;#MaximalRectangle&quot; class=&quot;headerlink&quot; title=&quot;MaximalRectangle&quot;&gt;&lt;/a&gt;MaximalRectangle&lt;/h1&gt;&lt;p&gt;dp思路：和上一题一样 84</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题08 array</title>
    <link href="http://example.com/2021/05/17/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9808-array/"/>
    <id>http://example.com/2021/05/17/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9808-array/</id>
    <published>2021-05-17T11:07:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h1><p>快排  看到leetcode有类似快排的算法，0换到左边，2换到右边 懒得实现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">           <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">           <span class="keyword">int</span> startPoint = start;</span><br><span class="line">           <span class="keyword">int</span> endPoint = end;</span><br><span class="line">           <span class="keyword">while</span> (startPoint &lt; endPoint) &#123;</span><br><span class="line">               <span class="keyword">while</span> (startPoint &lt; endPoint &amp;&amp; nums[endPoint] &gt; tmp) endPoint--;</span><br><span class="line">               <span class="keyword">if</span> (startPoint &lt; endPoint) nums[startPoint++] = nums[endPoint];</span><br><span class="line">               <span class="keyword">while</span> (startPoint &lt; endPoint &amp;&amp; nums[startPoint] &lt; tmp) startPoint++;</span><br><span class="line">               <span class="keyword">if</span> (startPoint &lt; endPoint) nums[endPoint--] = nums[startPoint];</span><br><span class="line">           &#125;</span><br><span class="line">           nums[startPoint] = tmp;</span><br><span class="line">           doSort(nums, start, startPoint - <span class="number">1</span>);</span><br><span class="line">           doSort(nums, startPoint + <span class="number">1</span>, end);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h1><p>这个问题要好好看看的 新的套路或者说新的思想，两种回溯，一种是深度优先搜索</p><p><img src="/images/pasted-73.png" alt="upload successful"></p><p><img src="/images/pasted-74.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subsets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> Solution().subsets(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;);</span><br><span class="line">        subsets.forEach(x -&gt; &#123;</span><br><span class="line">            x.forEach(System.out::print);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an integer array nums of unique elements, return all possible subsets (the power set).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The solution set must not contain duplicate subsets. Return the solution in any order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            getAns(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), ans);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAns</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                getAns(nums, i + <span class="number">1</span>, temp, ans);</span><br><span class="line">                temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lists = doSplit(list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                lists.add(Arrays.asList(num));</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">return</span> lists;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; doSplit(List&lt;Integer&gt; nums) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (nums.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums.get(<span class="number">0</span>), nums.get(<span class="number">1</span>)));</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> startNum = nums.get(<span class="number">0</span>);</span><br><span class="line">            nums.remove(<span class="number">0</span>);</span><br><span class="line">            nums.forEach(x -&gt; &#123;</span><br><span class="line">                res.add(Arrays.asList(startNum, x));</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; subs = doSplit(nums);</span><br><span class="line">            res.addAll(subs);</span><br><span class="line">            subs.forEach(x -&gt; &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(x);</span><br><span class="line">                tmp.add(<span class="number">0</span>, startNum);</span><br><span class="line">                res.add(tmp);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Word-Search"><a href="#Word-Search" class="headerlink" title="Word Search"></a>Word Search</h1><p>思路：首先定位首字母，然后查找周围匹配的下一个字母，注意的是这里需要回溯，一条路走不通，可能另一条就可以。且每个字母不能被重复用，所以加一个数组用来标记</p><p><img src="/images/pasted-69.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearch79</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().exist(<span class="keyword">new</span> <span class="keyword">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">        &#125;, <span class="string">&quot;aaaaaaaaaaaaa&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an m x n grid of characters board and a string word, return true if word exists in the grid.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1. 定位到字母开头</span></span><br><span class="line">            <span class="keyword">int</span> colLen = board[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">char</span> character = word.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span>[][] usage = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][colLen];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == character) &#123;</span><br><span class="line">                        <span class="comment">// 2. 判断是否能找完</span></span><br><span class="line">                        usage[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (doFind(board, i, j, -<span class="number">1</span>, <span class="number">1</span>, word, usage)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">else</span> usage[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> board          矩阵</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i              当前位置</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> previousDirect 从哪来</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> chPosi         要查找的字符位置</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doFind</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> previousDirect, <span class="keyword">int</span> chPosi, String word, <span class="keyword">boolean</span>[][] usage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (chPosi == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 0 1 2 3  上 下 左 右</span></span><br><span class="line">            <span class="keyword">if</span> (previousDirect != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; !usage[i - <span class="number">1</span>][j] &amp;&amp; board[i - <span class="number">1</span>][j] == word.charAt(chPosi)) &#123;</span><br><span class="line">                usage[i - <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (doFind(board, i - <span class="number">1</span>, j, <span class="number">1</span>, chPosi + <span class="number">1</span>, word, usage)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> usage[i - <span class="number">1</span>][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (previousDirect != <span class="number">1</span> &amp;&amp; i &lt; board.length - <span class="number">1</span> &amp;&amp; !usage[i + <span class="number">1</span>][j] &amp;&amp; board[i + <span class="number">1</span>][j] == word.charAt(chPosi)) &#123;</span><br><span class="line">                usage[i + <span class="number">1</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (doFind(board, i + <span class="number">1</span>, j, <span class="number">0</span>, chPosi + <span class="number">1</span>, word, usage)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> usage[i + <span class="number">1</span>][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (previousDirect != <span class="number">2</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; !usage[i][j - <span class="number">1</span>] &amp;&amp; board[i][j - <span class="number">1</span>] == word.charAt(chPosi)) &#123;</span><br><span class="line">                usage[i][j - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (doFind(board, i, j - <span class="number">1</span>, <span class="number">3</span>, chPosi + <span class="number">1</span>, word, usage)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> usage[i][j - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (previousDirect != <span class="number">3</span> &amp;&amp; j &lt; board[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; !usage[i][j + <span class="number">1</span>] &amp;&amp; board[i][j + <span class="number">1</span>] == word.charAt(chPosi)) &#123;</span><br><span class="line">                usage[i][j + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (doFind(board, i, j + <span class="number">1</span>, <span class="number">2</span>, chPosi + <span class="number">1</span>, word, usage)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> usage[i][j + <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Remove-Duplicates"><a href="#Remove-Duplicates" class="headerlink" title="Remove Duplicates"></a>Remove Duplicates</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicates80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().removeDuplicatesEasy(tmp));</span><br><span class="line">        System.out.println(Arrays.toString(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> point = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> same = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> sameTimes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len = nums.length;</span><br><span class="line">            <span class="keyword">while</span> (point &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[point] == same) sameTimes++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    same = nums[point];</span><br><span class="line">                    sameTimes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sameTimes &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = point + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">                        nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    len--;</span><br><span class="line">                    point--;</span><br><span class="line">                &#125;</span><br><span class="line">                point++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Success</span></span><br><span class="line"><span class="comment">         * Details</span></span><br><span class="line"><span class="comment">         * Runtime: 1 ms, faster than 16.69% of Java online submissions for Remove Duplicates from Sorted Array II.</span></span><br><span class="line"><span class="comment">         * Memory Usage: 38.6 MB, less than 99.46% of Java online submissions for Remove Duplicates from Sorted Array II.</span></span><br><span class="line"><span class="comment">         * Next challenges:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicatesFaster</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 差距 默认为-1，如果这一次和上一次相等 差值为0 如果这一次和上一次再相等差值++ 如果这一次和上一次不等，判断差距，移动，然后重设为-1；</span></span><br><span class="line">            <span class="keyword">int</span> range = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> point = nums.length - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> len = nums.length;</span><br><span class="line">            <span class="keyword">while</span> (point &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[point] == nums[point + <span class="number">1</span>]) range++;</span><br><span class="line">                <span class="keyword">if</span> (nums[point] != nums[point + <span class="number">1</span>] || point == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (range &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        len -= range;</span><br><span class="line">                        <span class="keyword">if</span> (point == <span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>] == nums[<span class="number">1</span>]) point--;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = point + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">                            nums[i] = nums[i + range];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    range = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                point--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicatesEasy</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">2</span> || n &gt; nums[i-<span class="number">2</span>])</span><br><span class="line">                        nums[i++] = n;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="SearchinRotatedSortedArrayII"><a href="#SearchinRotatedSortedArrayII" class="headerlink" title="SearchinRotatedSortedArrayII"></a>SearchinRotatedSortedArrayII</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchinRotatedSortedArrayII81</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().search2(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Before being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> posi = findSplitPosi(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            System.out.println(posi);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findSplitPosi</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; nums[nums.length - <span class="number">1</span>]) <span class="keyword">return</span> findSplitPosi(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> findSplitPosi(nums, start, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一次性找出 就不再像上一个一样先找出两个顺序数组了</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> doSearch(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> isSorted = nums[start] &lt; nums[end];</span><br><span class="line">            <span class="keyword">if</span> (isSorted &amp;&amp; target &gt; nums[start] &amp;&amp; target &gt; nums[end]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 在左区间？ 如果区间非顺序，那么也可能在右区间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) <span class="keyword">return</span> doSearch(nums, target, start, mid - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> doSearch(nums, target, start, mid - <span class="number">1</span>) || doSearch(nums, target, mid + <span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右区间？</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSorted) <span class="keyword">return</span> doSearch(nums, target, mid + <span class="number">1</span>, end);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> doSearch(nums, target, start, mid - <span class="number">1</span>) || doSearch(nums, target, mid + <span class="number">1</span>, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LargestRectangleArea"><a href="#LargestRectangleArea" class="headerlink" title="LargestRectangleArea"></a>LargestRectangleArea</h1><p>hard 用了dp的思想，用数组存储了面积最大值，这个算法24ms，67%，有待优化</p><p><img src="/images/pasted-70.png" alt="upload successful"></p><p><img src="/images/pasted-71.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargestRectangleArea</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().largestRectangleArea(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">               <span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given an array of integers heights representing the histogram&#x27;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：很简单，先准备一个数组用来存放每个数的最大面积，然后从第一个开始，先看数组有没有没有再动，如果右边的小于左边，那么第一个的最大面积为右边的数的最大面积，</span></span><br><span class="line"><span class="comment">     * 去算右边的最大面积且存储在数组中，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] areas = <span class="keyword">new</span> <span class="keyword">int</span>[heights.length];</span><br><span class="line">            Arrays.fill(areas, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">                max = Math.max(max, doFindArea(heights, i, areas));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到这个位置的最大面积</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> heights</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> posi</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> areas</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doFindArea</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> posi, <span class="keyword">int</span>[] areas)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当前最大面积不存在，开始查</span></span><br><span class="line">            <span class="keyword">if</span> (areas[posi] == <span class="number">0</span>) &#123;</span><br><span class="line">                areas[posi] = heights[posi];</span><br><span class="line">                <span class="keyword">int</span> i = posi, j = posi;</span><br><span class="line">                <span class="keyword">int</span> leftMax = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> rightMax = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 往左走，找到左边比自己小的最大值，本身区域也增加</span></span><br><span class="line">                <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                    <span class="comment">// 左边的比当前的高</span></span><br><span class="line">                    <span class="keyword">if</span> (heights[i] &gt; heights[posi]) areas[posi] += heights[posi];</span><br><span class="line">                    <span class="comment">// 往左走的时候如果左边和自己一样 那么值也一样</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] == heights[posi]) &#123;</span><br><span class="line">                        areas[posi] = areas[i];</span><br><span class="line">                        <span class="keyword">return</span> areas[posi];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 左边的比当前低</span></span><br><span class="line">                        <span class="comment">// 先看左边是否有最大面积，没有就算</span></span><br><span class="line">                        <span class="keyword">if</span> (areas[i] == <span class="number">0</span>) doFindArea(heights, i, areas);</span><br><span class="line">                        leftMax = areas[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往右走，找到右边比自己小的最大值，本身区域也增加</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; heights.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span> (heights[j] &gt;= heights[posi]) areas[posi] += heights[posi];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (areas[j] == <span class="number">0</span>) doFindArea(heights, j, areas);</span><br><span class="line">                        rightMax = areas[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 现在有了本身的大小，有了遇到的两个比自身小的数的区域最大值</span></span><br><span class="line">                areas[posi] = Math.max(Math.max(areas[posi], leftMax), rightMax);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> areas[posi];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Sort-Colors&quot;&gt;&lt;a href=&quot;#Sort-Colors&quot; class=&quot;headerlink&quot; title=&quot;Sort Colors&quot;&gt;&lt;/a&gt;Sort Colors&lt;/h1&gt;&lt;p&gt;快排  看到leetcode有类似快排的算法，0换到左边，2换到右边</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题07 array + matrix</title>
    <link href="http://example.com/2021/05/13/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9807-array/"/>
    <id>http://example.com/2021/05/13/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9807-array/</id>
    <published>2021-05-13T11:03:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a>Plus One</h1><p>easy </p><p><img src="/images/pasted-68.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusOne66</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> Solution().plusOne(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == digits.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    digits[i] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (digits[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                        digits[i] = <span class="number">0</span>;</span><br><span class="line">                        carry++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    digits[i] += carry;</span><br><span class="line">                    <span class="keyword">if</span> (digits[i] == <span class="number">10</span>) digits[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">                newArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.length; i++) &#123;</span><br><span class="line">                    newArr[i + <span class="number">1</span>] = digits[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> newArr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a>Set Matrix Zeroes</h1><p>难点在空间复杂度 O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetZeroes73</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Solution().setZeroes2(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            Set&lt;Integer&gt; cols = <span class="keyword">new</span> HashSet();</span><br><span class="line">            Set&lt;Integer&gt; rows = <span class="keyword">new</span> HashSet();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        cols.add(j);</span><br><span class="line">                        rows.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer col : cols) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">                    matrix[i][col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer row : rows) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[row].length; i++) &#123;</span><br><span class="line">                    matrix[row][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(1) space的算法 遍历 如果一个数为0 将对应第一行和第一列的值置为0a</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">            <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                        matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            <span class="comment">// set to zero</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 看第一行 和 第一列是否需要置空</span></span><br><span class="line">            <span class="keyword">boolean</span> isRow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> isCol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) isRow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) isCol = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isRow)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (isCol)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a>Search a 2D Matrix</h1><p>需要注意的是 二分法找行的时候，如果行首数小于target，还要判断行尾数是否也小于target，都小于才能<code>startRow = middleRow + 1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchMatrix74</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().searchMatrix(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>&#125;, &#123;<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">60</span>&#125;</span><br><span class="line">        &#125;, <span class="number">11</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Integers in each row are sorted from left to right.</span></span><br><span class="line"><span class="comment">     * The first integer of each row is greater than the last integer of the previous row.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> startRow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> endRow = matrix.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> startCol = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> endCol = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二分法查行</span></span><br><span class="line">            <span class="keyword">while</span> (startRow &lt; endRow) &#123;</span><br><span class="line">                <span class="keyword">int</span> middleRow = (startRow + endRow) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (matrix[middleRow][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">                    endRow = middleRow - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[middleRow][<span class="number">0</span>] &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[middleRow][endCol] &lt; target) startRow = middleRow + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> startRow = endRow = middleRow;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[middleRow][<span class="number">0</span>] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 二分查找列</span></span><br><span class="line">            <span class="keyword">while</span> (startCol &lt;= endCol) &#123;</span><br><span class="line">                <span class="keyword">int</span> middleCol = (startCol + endCol) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (matrix[startRow][middleCol] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[startRow][middleCol] &gt; target) &#123;</span><br><span class="line">                    endCol = middleCol - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[startRow][middleCol] &lt; target) &#123;</span><br><span class="line">                    startCol = middleCol + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Plus-One&quot;&gt;&lt;a href=&quot;#Plus-One&quot; class=&quot;headerlink&quot; title=&quot;Plus One&quot;&gt;&lt;/a&gt;Plus One&lt;/h1&gt;&lt;p&gt;easy &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-68.png&quot; </summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode每日三道题06 动态规划</title>
    <link href="http://example.com/2021/05/13/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9806-array/"/>
    <id>http://example.com/2021/05/13/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9806-array/</id>
    <published>2021-05-13T09:49:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h1><p>medium 动态规划题<br>一次ac<br><img src="/images/pasted-62.png" alt="upload successful"></p><p><img src="/images/pasted-59.png" alt="upload successful"></p><p>机器人只能向右和向下走，问走到终点几种方案，比较简单的经典动规</p><p>思路：在finish上方和左边到finish点个只有一种，记录下来，finish点左上方到达下面一个点是1种，到达右边也是一种，所以左上角到终点是<code>1*1 + 1*1 = 2</code> 种。所以对于每个点只要算上右边和下边的和就够了。</p><p><img src="/images/pasted-60.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePaths62</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().uniquePaths(<span class="number">7</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A robot is located at the top-left corner of a m x n grid (marked &#x27;Start&#x27; in the diagram below).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#x27;Finish&#x27; in the diagram below).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * How many possible unique paths are there?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Input: m = 3, n = 2</span></span><br><span class="line"><span class="comment">     * Output: 3</span></span><br><span class="line"><span class="comment">     * Explanation:</span></span><br><span class="line"><span class="comment">     * From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span></span><br><span class="line"><span class="comment">     * 1. Right -&gt; Down -&gt; Down</span></span><br><span class="line"><span class="comment">     * 2. Down -&gt; Down -&gt; Right</span></span><br><span class="line"><span class="comment">     * 3. Down -&gt; Right -&gt; Down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                matrix[m - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    matrix[i][j] = matrix[i + <span class="number">1</span>][j] + matrix[i][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a>Unique Paths II</h1><p>在上题基础上加了障碍物</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>思路：还是和上题一样，只不过每个节点算下和右和的时候如果有障碍物不算进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leetcode 的eg真是佛了，还有输入&#123;&#123;0&#125;&#125;和&#123;&#123;1&#125;&#125;，&#123;&#123;0，0&#125;，&#123;0，1&#125;&#125;即起点在终点，终点被堵住这种情况。</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-64.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniquePathsII63</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().uniquePathsWithObstacles(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>&#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A robot is located at the top-left corner of a m x n grid (marked &#x27;Start&#x27; in the diagram below).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#x27;Finish&#x27; in the diagram below).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Now consider if some obstacles are added to the grids. How many unique paths would there be?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * An obstacle and space is marked as 1 and 0 respectively in the grid.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">            <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][i] == <span class="number">1</span>) obstacleGrid[m - <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == n - <span class="number">2</span>) obstacleGrid[m - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> obstacleGrid[m - <span class="number">1</span>][i] = obstacleGrid[m - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][n - <span class="number">1</span>] == <span class="number">1</span>) obstacleGrid[i][n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == m - <span class="number">2</span>) obstacleGrid[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> obstacleGrid[i][n - <span class="number">1</span>] = obstacleGrid[i + <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        obstacleGrid[i][j] = obstacleGrid[i + <span class="number">1</span>][j] + obstacleGrid[i][j + <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h1><p><img src="/images/pasted-67.png" alt="upload successful"></p><p>思路和上面两题一样 动规</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Solution &#123;</span><br><span class="line">        public int minPathSum(int[][] grid) &#123;</span><br><span class="line">            int m = grid.length;</span><br><span class="line">            int n = grid[0].length;</span><br><span class="line">            for (int i = m - 2; i &gt;= 0; i--) grid[i][n - 1] +=  grid[i + 1][n - 1];</span><br><span class="line">            for (int i = n - 2; i &gt;= 0; i--) grid[m - 1][i] += grid[m - 1][i + 1];</span><br><span class="line">            for (int i = m - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">                for (int j = n - 2; j &gt;= 0; j--) &#123;</span><br><span class="line">                    grid[i][j] += Math.min(grid[i + 1][j], grid[i][j + 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return grid[0][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unique-Paths&quot;&gt;&lt;a href=&quot;#Unique-Paths&quot; class=&quot;headerlink&quot; title=&quot;Unique Paths&quot;&gt;&lt;/a&gt;Unique Paths&lt;/h1&gt;&lt;p&gt;medium 动态规划题&lt;br&gt;一次ac&lt;br&gt;&lt;img s</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题05 array</title>
    <link href="http://example.com/2021/04/12/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9805-array/"/>
    <id>http://example.com/2021/04/12/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%9805-array/</id>
    <published>2021-04-12T14:30:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Merge-intervals"><a href="#Merge-intervals" class="headerlink" title="Merge intervals"></a>Merge intervals</h1><span id="more"></span><p>medium</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：合并有交集的集合</span></span><br><span class="line"><span class="comment">     * Input: intervals = [[1,3],[2,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment">     * Output: [[1,6],[8,10],[15,18]]</span></span><br><span class="line"><span class="comment">     * Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals.length == <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"><span class="comment">//            Arrays.sort(intervals, Comparator.comparingInt(x -&gt; x[0]));</span></span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; sorted = Arrays.stream(intervals).sorted(Comparator.comparingInt(x -&gt; x[<span class="number">0</span>])).collect(Collectors.toList());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sorted.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sorted.get(i)[<span class="number">1</span>] &gt;= sorted.get(i + <span class="number">1</span>)[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] ints = &#123;sorted.get(i)[<span class="number">0</span>], Math.max(sorted.get(i + <span class="number">1</span>)[<span class="number">1</span>], sorted.get(i)[<span class="number">1</span>])&#125;;</span><br><span class="line">                    sorted.set(i, ints);</span><br><span class="line">                    sorted.remove(i + <span class="number">1</span>);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sorted.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="Insert-intervals"><a href="#Insert-intervals" class="headerlink" title="Insert intervals"></a>Insert intervals</h1><p>medium 思路：先确定左端点，在确定右端点，在端点之外的都添加到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert2(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">           List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">           <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">               res.add(newInterval);</span><br><span class="line">               <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 找到开始合并的数组</span></span><br><span class="line">           <span class="keyword">int</span> newS = newInterval[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">int</span> newE = newInterval[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> posi = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (posi &lt; intervals.length &amp;&amp; newS &gt;= intervals[posi][<span class="number">0</span>]) posi++;</span><br><span class="line">           posi--;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; posi; i++) res.add(intervals[i]);</span><br><span class="line">           <span class="keyword">if</span> (posi &gt;= intervals.length) res.add(newInterval);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (posi &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (intervals[posi][<span class="number">1</span>] &lt; newS) &#123;</span><br><span class="line">                       posi++;</span><br><span class="line">                       res.add(intervals[posi - <span class="number">1</span>]);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       newS = Math.min(newS, intervals[posi][<span class="number">0</span>]);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> posi++;</span><br><span class="line">               <span class="comment">// 确定右端点</span></span><br><span class="line">               <span class="keyword">while</span> (posi &lt; intervals.length &amp;&amp; intervals[posi][<span class="number">1</span>] &lt; newE) posi++;</span><br><span class="line">               <span class="keyword">if</span> (posi &lt; intervals.length &amp;&amp; intervals[posi][<span class="number">0</span>] &lt;= newE) newE = intervals[posi++][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">               res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newS, newE&#125;);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = posi; i &lt; intervals.length; i++) &#123;</span><br><span class="line">                   res.add(intervals[i]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="GenerateMatrix"><a href="#GenerateMatrix" class="headerlink" title="GenerateMatrix"></a>GenerateMatrix</h1><p>medium 生成矩阵 一次AC，思路是每次都填充好外边一圈，然后调用函数反复填充外边一圈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateMatrix59</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> Solution().generateMatrix(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] anInt : ints) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(anInt));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Input: n = 3</span></span><br><span class="line"><span class="comment">     * Output: [[1,2,3],[8,9,4],[7,6,5]]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">            doGenerate(matrix, <span class="number">0</span>, n, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> matrix;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> matrix 要生产的矩阵</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> start  起始位置</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nums   填充数量</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> num    填充的数字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGenerate</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> start, <span class="keyword">int</span> nums, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// nums &lt;=0 结束</span></span><br><span class="line">            <span class="keyword">if</span> (nums &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 填充第一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                matrix[start][start + i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                matrix[start + i + <span class="number">1</span>][start + nums - <span class="number">1</span>] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                matrix[start + nums - <span class="number">1</span>][start + nums - <span class="number">2</span> - i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">2</span>; i++) &#123;</span><br><span class="line">                matrix[start + nums - <span class="number">2</span> - i][start] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            doGenerate(matrix, ++start, nums - <span class="number">2</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Merge-intervals&quot;&gt;&lt;a href=&quot;#Merge-intervals&quot; class=&quot;headerlink&quot; title=&quot;Merge intervals&quot;&gt;&lt;/a&gt;Merge intervals&lt;/h1&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题 04 动规</title>
    <link href="http://example.com/2021/04/09/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%98-04-%E5%8A%A8%E8%A7%84/"/>
    <id>http://example.com/2021/04/09/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%98-04-%E5%8A%A8%E8%A7%84/</id>
    <published>2021-04-09T14:13:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maxium-subarray"><a href="#Maxium-subarray" class="headerlink" title="Maxium subarray"></a>Maxium subarray</h1><p>easy</p><span id="more"></span><p> 感觉动态规划切割问题的时候要将问题切割到每一个或者第一个开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarray53</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().maxSubArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：</span></span><br><span class="line"><span class="comment">     * Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span></span><br><span class="line"><span class="comment">     * Output: 6</span></span><br><span class="line"><span class="comment">     * Explanation: [4,-1,2,1] has the largest sum = 6.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 动态规划：将问题切割到小问题上，从第一个元素开始，dp[i]表示以i结尾的最大连续子序和大小</span></span><br><span class="line"><span class="comment">     * dp[i] = max&#123;nums[i],dp[i-1]+nums[i]&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Maximum Subarray.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 38.4 MB, less than 99.75% of Java online submissions for Maximum Subarray.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 记录上一个最大子序和</span></span><br><span class="line">            <span class="keyword">int</span> lastMaxSubArray = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 全部最大子序和</span></span><br><span class="line">            <span class="keyword">int</span> max = lastMaxSubArray;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                lastMaxSubArray = Math.max(lastMaxSubArray + nums[i], nums[i]);</span><br><span class="line">                max = Math.max(max, lastMaxSubArray);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Spiral-Matrix"><a href="#Spiral-Matrix" class="headerlink" title="Spiral Matrix"></a>Spiral Matrix</h1><p>medium</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiralMatrix54</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().spiralOrder(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;, &#123;<span class="number">4</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     * Given an m x n matrix, return all elements of the matrix in spiral order.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line"><span class="comment">     * Output: [1,2,3,6,9,8,7,4,5]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Spiral Matrix.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 37 MB, less than 66.66% of Java online submissions for Spiral Matrix.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            doSpiralARound(matrix, <span class="number">0</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length, matrix.length, list);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSpiralARound</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> length, <span class="keyword">int</span> height, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (length &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span> || x &gt; matrix.length - <span class="number">1</span> || y &gt; matrix[<span class="number">0</span>].length - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 上行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                res.add(matrix[x][y + i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; i++) &#123;</span><br><span class="line">                res.add(matrix[x + i][y + length - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 下行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    res.add(matrix[x + height - <span class="number">1</span>][y + i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左列</span></span><br><span class="line">                <span class="keyword">if</span> (length &gt; <span class="number">1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = height - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    res.add(matrix[x + i][y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            doSpiralARound(matrix, x + <span class="number">1</span>, y + <span class="number">1</span>, length - <span class="number">2</span>, height - <span class="number">2</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h1><p>medium </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGame55</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().canJump(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：判断是否能到终点，和JumpGameII54差不多 这个是简单版本 都用贪心算法即可</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Runtime: 1 ms, faster than 83.87% of Java online submissions for Jump Game.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 40.8 MB, less than 75.58% of Java online submissions for Jump Game.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 当前跳跃的最远点</span></span><br><span class="line">            <span class="keyword">int</span> currentMaxJump = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 可以跳的最远步数 对比取最大值</span></span><br><span class="line">            <span class="keyword">int</span> canMaxJump = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                canMaxJump = Math.max(nums[i] + i, canMaxJump);</span><br><span class="line">                <span class="comment">// 遍历完成 开始跳</span></span><br><span class="line">                <span class="keyword">if</span> (i == currentMaxJump) &#123;</span><br><span class="line">                    currentMaxJump = canMaxJump;</span><br><span class="line">                    canMaxJump = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> currentMaxJump &gt;= nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Maxium-subarray&quot;&gt;&lt;a href=&quot;#Maxium-subarray&quot; class=&quot;headerlink&quot; title=&quot;Maxium subarray&quot;&gt;&lt;/a&gt;Maxium subarray&lt;/h1&gt;&lt;p&gt;easy&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题 03 动规 指针</title>
    <link href="http://example.com/2021/04/09/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%98-03-%E5%8A%A8%E8%A7%84-%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2021/04/09/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%98-03-%E5%8A%A8%E8%A7%84-%E6%8C%87%E9%92%88/</id>
    <published>2021-04-09T09:23:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trapping-rain-water-hard"><a href="#Trapping-rain-water-hard" class="headerlink" title="Trapping rain water   -hard"></a>Trapping rain water   -hard</h1><p>三种解题方法和思路，最好的80%</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrappingRainWater42</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution3().trap(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 涉及数组 动规 双指针</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：首先找到最高点，分别向左右两边找第二高的点，找到第二高的点，将第二高的值减去包裹的所有高度，</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Runtime: 2 ms, faster than 21.28% of Java online submissions for Trapping Rain Water.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 38.3 MB, less than 86.97% of Java online submissions for Trapping Rain Water.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> doTrap(height, <span class="number">0</span>, height.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doTrap</span><span class="params">(<span class="keyword">int</span>[] height, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= end - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> heighestIndex = findMaxIndex(height, start, end, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> totalWater = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> leftSecondHeightIndex = findMaxIndex(height, start, heighestIndex - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> rightSecondHeightIndex = findMaxIndex(height, heighestIndex + <span class="number">1</span>, end, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 找到左边包含水源</span></span><br><span class="line">            <span class="keyword">if</span> (leftSecondHeightIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = leftSecondHeightIndex + <span class="number">1</span>; i &lt;= heighestIndex - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    totalWater += height[leftSecondHeightIndex] - height[i];</span><br><span class="line">                &#125;</span><br><span class="line">                totalWater += doTrap(height, start, leftSecondHeightIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到右边包含水源</span></span><br><span class="line">            <span class="keyword">if</span> (rightSecondHeightIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = heighestIndex + <span class="number">1</span>; i &lt;= rightSecondHeightIndex - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    totalWater += height[rightSecondHeightIndex] - height[i];</span><br><span class="line">                &#125;</span><br><span class="line">                totalWater += doTrap(height, rightSecondHeightIndex, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totalWater;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到最高点的下标</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> direction 靠近哪边的最高点，因为可能有高度相同， 1：表示靠近右边的最大值，0表示靠近左边的最大值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxIndex</span><span class="params">(<span class="keyword">int</span>[] height, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 相邻的两个墙壁找最高无意义</span></span><br><span class="line">            <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp;</span><br><span class="line">            <span class="keyword">if</span> (direction == <span class="number">0</span>) &#123;</span><br><span class="line">                tmp = start;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (height[tmp] &lt; height[i]) tmp = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = end;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (height[tmp] &lt; height[i]) tmp = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一种太慢，换种，两个指针，一个头，一个尾 都不为0，左指针又走到比自身大的，右指针左走到比自己大的，分别计算两个指针刚刚和现在的位置包含的水量。</span></span><br><span class="line"><span class="comment">     * 直到左右指针相遇结束</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Runtime: 2 ms, faster than 21.28% of Java online submissions for Trapping Rain Water.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 38.3 MB, less than 86.97% of Java online submissions for Trapping Rain Water.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> totalWater = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> startPoint = <span class="number">0</span>, endPoint = height.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> recordStart, recordEnd;</span><br><span class="line">            <span class="keyword">while</span> (startPoint &lt; endPoint) &#123;</span><br><span class="line">                <span class="comment">// 直到比自己大</span></span><br><span class="line">                recordStart = startPoint;</span><br><span class="line">                recordEnd = endPoint;</span><br><span class="line">                <span class="comment">// 指针走的时候会有递减的情况 如果指针一次走到底了 那么需要重置指针 让另一个指针走</span></span><br><span class="line">                <span class="keyword">while</span> (startPoint &lt; endPoint - <span class="number">1</span> &amp;&amp; height[recordStart] &gt;= height[startPoint + <span class="number">1</span>]) startPoint++;</span><br><span class="line">                startPoint++;</span><br><span class="line">                <span class="comment">// reset</span></span><br><span class="line">                <span class="keyword">if</span> (startPoint &gt;= endPoint &amp;&amp; height[recordStart] &gt; height[startPoint]) startPoint = recordStart;</span><br><span class="line">                <span class="keyword">while</span> (startPoint &lt; endPoint - <span class="number">1</span> &amp;&amp; height[recordEnd] &gt;= height[endPoint - <span class="number">1</span>]) endPoint--;</span><br><span class="line">                endPoint--;</span><br><span class="line">                <span class="keyword">if</span> (startPoint &gt;= endPoint &amp;&amp; height[endPoint] &lt; height[recordEnd]) endPoint = recordEnd;</span><br><span class="line">                <span class="comment">// 分别计算水量</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = recordStart + <span class="number">1</span>; i &lt; startPoint; i++) &#123;</span><br><span class="line">                    totalWater += height[recordStart] - height[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endPoint + <span class="number">1</span>; i &lt; recordEnd; i++) &#123;</span><br><span class="line">                    totalWater += height[recordEnd] - height[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totalWater;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面那个思路稍微修改下即可 80%  不重置指针，而是先找到最大值，左指针和右指针最高只能找到最大值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Runtime: 1 ms, faster than 81.80% of Java online submissions for Trapping Rain Water.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 38 MB, less than 99.27% of Java online submissions for Trapping Rain Water.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> totalWater = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> startPoint = <span class="number">0</span>, endPoint = height.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> recordStart, recordEnd;</span><br><span class="line">            <span class="comment">// 找到最大值 左右指针只能走到最大值</span></span><br><span class="line">            <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (height[maxIndex] &lt; height[i]) maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (startPoint &lt; endPoint) &#123;</span><br><span class="line">                <span class="comment">// 直到比自己大</span></span><br><span class="line">                recordStart = startPoint;</span><br><span class="line">                recordEnd = endPoint;</span><br><span class="line">                <span class="comment">// 指针走的时候会有递减的情况 如果指针一次走到底了 那么需要重置指针 让另一个指针走</span></span><br><span class="line">                <span class="keyword">while</span> (startPoint &lt; maxIndex &amp;&amp; height[recordStart] &gt;= height[startPoint + <span class="number">1</span>]) startPoint++;</span><br><span class="line">                <span class="keyword">if</span> (startPoint &lt; maxIndex) startPoint++;</span><br><span class="line">                <span class="keyword">while</span> (endPoint &gt; maxIndex &amp;&amp; height[recordEnd] &gt;= height[endPoint - <span class="number">1</span>]) endPoint--;</span><br><span class="line">                <span class="keyword">if</span> (endPoint &gt; maxIndex) endPoint--;</span><br><span class="line">                <span class="comment">// 分别计算水量</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = recordStart + <span class="number">1</span>; i &lt; startPoint; i++) &#123;</span><br><span class="line">                    totalWater += height[recordStart] - height[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endPoint + <span class="number">1</span>; i &lt; recordEnd; i++) &#123;</span><br><span class="line">                    totalWater += height[recordEnd] - height[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totalWater;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="JumpGame-II-45-medium"><a href="#JumpGame-II-45-medium" class="headerlink" title="JumpGame II 45 medium"></a>JumpGame II 45 medium</h1><p>动规和贪心的解决方案</p><p>贪心算法：</p><p><img src="/images/pasted-48.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpGameII45</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution2().jump(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 问题：</span></span><br><span class="line"><span class="comment">     * Given an array of non-negative integers nums, you are initially positioned at the first index of the array.</span></span><br><span class="line"><span class="comment">     * Each element in the array represents your maximum jump length at that position.</span></span><br><span class="line"><span class="comment">     * Your goal is to reach the last index in the minimum number of jumps.</span></span><br><span class="line"><span class="comment">     * You can assume that you can always reach the last index.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 当前位置值为最大跳跃步数，如何移动最小次数跳到最后</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：先用动态规划的思想，从低到高，从最后开始算最优跳跃次数 -1表示无法到达终点</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Jump Game II.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 36.3 MB, less than 85.37% of Java online submissions for Jump Game II.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] jumpTimes = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">            Arrays.fill(jumpTimes, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    jumpTimes[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每位再遍历后面的次数 选最小的</span></span><br><span class="line">                <span class="keyword">int</span> min = jumpTimes[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i]; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + j &lt; nums.length &amp;&amp; min &gt; jumpTimes[i + j] &amp;&amp; jumpTimes[i + j] != -<span class="number">1</span>) min = jumpTimes[i + j];</span><br><span class="line">                &#125;</span><br><span class="line">                jumpTimes[i] = min + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> jumpTimes[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改造成贪心算法</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：选择能跳到的范围内的，最远下一次跳跃距离</span></span><br><span class="line"><span class="comment">     * 当前的currentJumpEnd记录能跳到的最远位置，在当前位置和最远位置里面挑出跳的最远的方案：max，i==currentPosi表明已经找到最大跳远距离了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> jumpTimes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> currentJumpEnd = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 记录能跳的最远位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                max = Math.max(max, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == currentJumpEnd) &#123;</span><br><span class="line">                    jumpTimes++;</span><br><span class="line">                    currentJumpEnd = max;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> jumpTimes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Rotate-image"><a href="#Rotate-image" class="headerlink" title="Rotate image"></a>Rotate image</h1><p>medium</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateImage48</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Solution().rotater2(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runtime: 3 ms, faster than 100.00% of Java online submissions for Rotate Image.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 39 MB, less than 48.87% of Java online submissions for Rotate Image.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从第一列开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                    swap(matrix, i, j, j, i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    swap(matrix, i, j, i, matrix.length - <span class="number">1</span> - j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.stream(matrix).forEach(x -&gt; System.out.println(Arrays.toString(x)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> newI, <span class="keyword">int</span> newJ)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[newI][newJ];</span><br><span class="line">            matrix[newI][newJ] = matrix[i][j];</span><br><span class="line">            matrix[i][j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotater2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从第一列开始</span></span><br><span class="line">            StringBuffer out = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            out.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="comment">// 列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">                out.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = matrix.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    out.append(matrix[j][i]);</span><br><span class="line">                    <span class="keyword">if</span> (j!=<span class="number">0</span>) out.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != matrix.length-<span class="number">1</span>) out.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println(out.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Trapping-rain-water-hard&quot;&gt;&lt;a href=&quot;#Trapping-rain-water-hard&quot; class=&quot;headerlink&quot; title=&quot;Trapping rain water   -hard&quot;&gt;&lt;/a&gt;Trapping ra</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://example.com/tags/Array/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 每日三道题 02 array + 回溯</title>
    <link href="http://example.com/2021/04/08/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%98-02-array-%E5%9B%9E%E6%BA%AF/"/>
    <id>http://example.com/2021/04/08/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%89%E9%81%93%E9%A2%98-02-array-%E5%9B%9E%E6%BA%AF/</id>
    <published>2021-04-08T15:44:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Combination-Sum-39"><a href="#Combination-Sum-39" class="headerlink" title="Combination Sum 39"></a>Combination Sum 39</h1><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum39</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> Solution().combinationSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>&#125;, <span class="number">9</span>);</span><br><span class="line">        lists.forEach(System.out::println);</span><br><span class="line">        System.out.println(lists.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：用给的数组 拼成目标数，数组的数可以被使用多次</span></span><br><span class="line"><span class="comment">     * Input: candidates = [2,3,6,7], target = 7</span></span><br><span class="line"><span class="comment">     * Output: [[2,2,3],[7]]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：留一个list用于记录使用过的数，递归，每次遍历数组的数，用target减去，如果为0说明路径可行，添加</span></span><br><span class="line"><span class="comment">     * 但是只这样的话，结果会有重复，为了不重复，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            generatePath(Arrays.stream(candidates).sorted().toArray(), <span class="number">0</span>, target, <span class="keyword">new</span> LinkedList&lt;&gt;(), res);</span><br><span class="line"><span class="comment">//            res.stream().forEach(x -&gt; x.sort(Comparator.comparingInt(x2 -&gt; x2)));</span></span><br><span class="line"><span class="comment">//            return res.stream().distinct().collect(Collectors.toList());</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generatePath</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; allPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> deletedLastPath = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target - candidates[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    path.add(candidates[i]);</span><br><span class="line">                    allPath.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">                    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target - candidates[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    path.add(candidates[i]);</span><br><span class="line">                    generatePath(candidates, i, target - candidates[i], path, allPath);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!deletedLastPath) &#123;</span><br><span class="line">                        <span class="comment">// 本层结束后删除本层添加的节点</span></span><br><span class="line">                        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                        deletedLastPath = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Combination-Sum-II-40"><a href="#Combination-Sum-II-40" class="headerlink" title="Combination Sum II 40"></a>Combination Sum II 40</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSumII40</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> Solution().combinationSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, <span class="number">2</span>);</span><br><span class="line">        lists.forEach(System.out::println);</span><br><span class="line">        System.out.println(lists.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：用给的数组 拼成目标数，数组的数可以使用一次  39题的加强版</span></span><br><span class="line"><span class="comment">     * Input: candidates = [2,3,6,7], target = 7</span></span><br><span class="line"><span class="comment">     * Output: [[2,2,3],[7]]</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：留一个list用于记录使用过的数，递归，每次遍历数组的数，用target减去，如果为0说明路径可行，添加</span></span><br><span class="line"><span class="comment">     * 但是只这样的话，结果会有重复，为了不重复，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 和 39 题对比 ，为了防止重复 先排序，后再在循环中跳过重复字符。</span></span><br><span class="line"><span class="comment">     * 为了每个字符只使用一次，排序后下一层传递的开始值为当前值+1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Runtime: 6 ms, faster than 28.62% of Java online submissions for Combination Sum II.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 39.5 MB, less than 22.30% of Java online submissions for Combination Sum II.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            generatePath(Arrays.stream(candidates).sorted().toArray(), <span class="number">0</span>, target, <span class="keyword">new</span> LinkedList&lt;&gt;(), res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generatePath</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; allPath)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target - candidates[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    path.add(candidates[i]);</span><br><span class="line">                    allPath.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">                    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target - candidates[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    path.add(candidates[i]);</span><br><span class="line">                    generatePath(candidates, i + <span class="number">1</span>, target - candidates[i], path, allPath);</span><br><span class="line">                    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 为了防止重复 跳到最后一个不一致的</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; candidates.length - <span class="number">1</span> &amp;&amp; candidates[i] == candidates[i + <span class="number">1</span>]) i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="First-Missing-Positive-41"><a href="#First-Missing-Positive-41" class="headerlink" title="First Missing Positive 41"></a>First Missing Positive 41</h1><p>hard题</p><p>网上找的图<br><img src="/images/pasted-47.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">               <span class="comment">// 换</span></span><br><span class="line">               <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span> &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                   swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">                   i--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 桶排序后的数组顺序遍历不满足nums[i]= i+1的就是</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">           nums[a] = nums[b];</span><br><span class="line">           nums[b] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Combination-Sum-39&quot;&gt;&lt;a href=&quot;#Combination-Sum-39&quot; class=&quot;headerlink&quot; title=&quot;Combination Sum 39&quot;&gt;&lt;/a&gt;Combination Sum 39&lt;/h1&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://example.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>leet code 每日三道题 01 array+binary search</title>
    <link href="http://example.com/2021/03/26/LeetCode/"/>
    <id>http://example.com/2021/03/26/LeetCode/</id>
    <published>2021-03-26T15:43:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leet-code-每日三道题-01-array-binary-search"><a href="#leet-code-每日三道题-01-array-binary-search" class="headerlink" title="leet code 每日三道题 01 array+binary search"></a>leet code 每日三道题 01 array+binary search</h1><span id="more"></span><h2 id="29题-除法-M"><a href="#29题-除法-M" class="headerlink" title="29题 除法 M"></a>29题 除法 M</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivideTwoIntegers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(solution.divideTwo(Integer.MIN_VALUE, Integer.MAX_VALUE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 问题：不使用 * / % 符号完成除法</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：1. 暴力算法，除法可以看作减法，每次减去被除数，当结果&lt;0说明结束，但是这样会导致被除数为1的时候循环次数为被除数，会超时的</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：2. 首先位运算 除2：`&gt;&gt;1` 乘2：`&lt;&lt;1`。然后我们看整个除法表达式，比如 `13/4 = 3 ==&gt; 13 = 4 * 3`</span></span><br><span class="line"><span class="comment">     * 换算成二进制：`1101 = 4 * 0010+ 4* 0001` 也就是4个 `0010`和`0001`，所以可以看出规律，那就是除法的结果必定为除数的倍数的二进制位。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 由此可以遍历二进制数（从 1000.. 遍历到 000..001），题目的最大是32位，现在假如最高8位，那么从最高位开始 `1000 0000 * 4 &gt; 1010`</span></span><br><span class="line"><span class="comment">     * 循环直到发现`0010(2) * 4 &lt; 1101`,记录下`0010`, 那么剩下是数就是 13-8=5 ,继续遍历`0001 * 4 &lt; 5` 记录下`0001`，遍历结束，</span></span><br><span class="line"><span class="comment">     * 结果为 `0001 *4 + 0010 * 4` 即 `0001 + 0010 `（3） * 4 ，最后结果为 3。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 具体实现中，为了不使用乘法符号完成乘法，使用`&lt;&lt;`  比如 `0001`和`0010`分别乘4就是 4 和 4&lt;&lt;1，所以可以定义一个初始数组arr，</span></span><br><span class="line"><span class="comment">     * `arr[0]`放被除数，1,2,3 分别是前一位的乘2即&lt;&lt;1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">boolean</span> isPos = (dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//            boolean isMin = dividend == Integer.MIN_VALUE;</span></span><br><span class="line">            <span class="keyword">long</span> array[] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">            divisor = Math.abs(divisor);</span><br><span class="line">            <span class="keyword">long</span> dividentInput = dividend;</span><br><span class="line">            dividentInput = Math.abs(dividentInput);</span><br><span class="line">            array[<span class="number">0</span>] = divisor;</span><br><span class="line">            <span class="keyword">int</span> truePosi = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 当前位都是前一位的*2 但是当tmp溢出的时候就可以停止了，两个正数的相除结果肯定是正数</span></span><br><span class="line">                array[i] = array[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                truePosi = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从最高位开始遍历，做减法 1. 如果两个数为正 被除数减法，结果加法 2. 被除数为负， 结果加法，被除数加法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = truePosi; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt;= dividentInput) &#123;</span><br><span class="line">                    <span class="comment">// 假如 27位是结果 那么 27位应该是 array[27]/divisor 也就是 2的27次方</span></span><br><span class="line">                    result += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                    dividentInput -= array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE) result = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; Integer.MIN_VALUE) result = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (isPos) <span class="keyword">return</span> (<span class="keyword">int</span>) result;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>) -result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 除数 被除数 0：同为正，1：同为负号，异号（2：被除数正，除数负 3：被除数负，除数正）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Runtime: 1 ms, faster than 99.98% of Java online submissions for Divide Two Integers.</span></span><br><span class="line"><span class="comment">         * Memory Usage: 36.3 MB, less than 27.88% of Java online submissions for Divide Two Integers.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> dividend</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> divisor</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divideTwo</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (dividend == divisor) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (divisor == Integer.MAX_VALUE &amp;&amp; divisor == -dividend) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (divisor == Integer.MAX_VALUE || divisor == Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">boolean</span> isPos = (dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 除数确保不会溢出了</span></span><br><span class="line">            <span class="keyword">if</span> (divisor &lt; <span class="number">0</span>) divisor = -divisor;</span><br><span class="line">            array[<span class="number">0</span>] = divisor;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                array[i] = array[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 被除数如果是最小值要另外判断</span></span><br><span class="line">            <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dividend &lt;= -array[i]) &#123;</span><br><span class="line">                        dividend += array[i];</span><br><span class="line">                        result += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                        <span class="keyword">if</span> (result&lt;<span class="number">0</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dividend &lt; <span class="number">0</span>) dividend = -dividend;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dividend &gt;= array[i]) &#123;</span><br><span class="line">                        dividend -= array[i];</span><br><span class="line">                        result += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPos) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题：不使用 * / % 符号完成除法</p><p>思路：1. 暴力算法，除法可以看作减法，每次减去被除数，当结果&lt;0说明结束，但是这样会导致被除数为1的时候循环次数为被除数，会超时的</p><p>思路：2. 首先位运算 除2：<code>&gt;&gt;1</code> 乘2：<code>&lt;&lt;1</code>。然后我们看整个除法表达式，比如 <code>13/4 = 3 ==&gt; 13 = 4 * 3</code> 换算成二进制：<code>1101 = 4 * 0010+ 4* 0001</code> 也就是4个 <code>0010</code>和<code>0001</code>，所以可以看出规律，那就是除法的结果必定为除数的倍数的二进制位。</p><p>由此可以遍历二进制数（从 1000.. 遍历到 000..001），题目的最大是32位，现在假如最高8位，那么从最高位开始 <code>1000 0000 * 4 &gt; 1010</code> 循环直到发现<code>0010(2) * 4 &lt; 1101</code>,记录下<code>0010</code>, 那么剩下是数就是 13-8=5 ,继续遍历<code>0001 * 4 &lt; 5</code> 记录下<code>0001</code>，遍历结束，结果为 <code>0001 *4 + 0010 * 4</code> 即 <code>0001 + 0010 </code>（3） * 4 ，最后结果为 3。</p><p>具体实现中，为了不使用乘法符号完成乘法，使用<code>&lt;&lt;</code>  比如 <code>0001</code>和<code>0010</code>分别乘4就是 4 和 4&lt;&lt;1，所以可以定义一个初始数组arr，<code>arr[0]</code>放被除数，1,2,3 分别是前一位的乘2即&lt;&lt;1。</p><h2 id="33-Search-in-Rotated-Sorted-Array-M"><a href="#33-Search-in-Rotated-Sorted-Array-M" class="headerlink" title="33 Search in Rotated Sorted Array M"></a>33 Search in Rotated Sorted Array M</h2><p>这题应该挺简单的，不停二分就是了，既然100%了就不看官方答案了</p><pre><code> * 题目是给定一个未知的数，数组会根据这个数旋转， * For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. * * 思路：二分法，反正第一个数肯定是比最后一位大，数组二分，筛选出目标数组，第一个数比分组后的最后一个大就是目标数组， * 将目标数组再次二分，这个数再比对两个数组的最后一个数，找出最小的所在的数组，直到目标数组为1 记录下标， * * 找到记录下标后说明确定了分割位置，将数组分割成两个有序数组，然后二分查找即可 </code></pre><p>  代码逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInRotatedSortedArray33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().search(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目是给定一个未知的数，数组会根据这个数旋转，</span></span><br><span class="line"><span class="comment">     * For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：二分法，反正第一个数肯定是比最后一位大，数组二分，筛选出目标数组，第一个数比分组后的最后一个大就是目标数组，</span></span><br><span class="line"><span class="comment">     * 将目标数组再次二分，这个数再比对两个数组的最后一个数，找出最小的所在的数组，直到目标数组为1 记录下标，</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 找到记录下标后说明确定了分割位置，将数组分割成两个有序数组，然后二分查找即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array.</span></span><br><span class="line"><span class="comment">     * Memory Usage: 38.3 MB, less than 52.83% of Java online submissions for Search in Rotated Sorted Array.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 定位到分割位置</span></span><br><span class="line">            <span class="keyword">int</span> posi = doSplitArray(nums, nums[<span class="number">0</span>], <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 二分查找即可</span></span><br><span class="line">            <span class="keyword">int</span> res = doBinarySearch(nums, <span class="number">0</span>, posi - <span class="number">1</span>, target);</span><br><span class="line">            <span class="keyword">if</span> (res != -<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> doBinarySearch(nums, posi, nums.length - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出分割位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doSplitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 两个数组 start-mid &amp; mid-end 找出其中最后一个数比n小的</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= nums[start] &amp;&amp; n &lt; nums[end]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; nums[start] &amp;&amp; n &gt; nums[end]) <span class="keyword">return</span> start;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= nums[start] &amp;&amp; n &gt; nums[end]) &#123;</span><br><span class="line">                <span class="comment">// 判断分割点在左右哪个数组</span></span><br><span class="line">                <span class="keyword">if</span> (n &lt;= nums[mid]) <span class="keyword">return</span> doSplitArray(nums, n, mid + <span class="number">1</span>, end);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> doSplitArray(nums, n, start, mid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doBinarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end || (start == end &amp;&amp; nums[start] != target)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) <span class="keyword">return</span> doBinarySearch(nums, start, mid, target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> doBinarySearch(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/pasted-45.png" alt="upload successful"></p><h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-M"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-M" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array  M"></a>34. Find First and Last Position of Element in Sorted Array  M</h2><p>二分就行的题目 ， 30分钟 100%+95% </p><ul><li>题目<ul><li>给定一个排序数组，找出目标的起始位置和终点位置下标 </li><li>思路：先定位到目标，然后从目标往前和往后看是否连续，记录最后一次连续下标</li><li>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</li><li>If target is not found in the array, return [-1, -1].</li><li>Follow up: Could you write an algorithm with O(log n) runtime complexity?</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> res = binarySearch(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">            <span class="keyword">if</span> (res == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> s = res, e = res;</span><br><span class="line">            <span class="comment">// 往前查看连续</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; <span class="number">0</span> &amp;&amp; nums[s] == nums[s - <span class="number">1</span>]) s--;</span><br><span class="line">            <span class="comment">// 往后查看</span></span><br><span class="line">            <span class="keyword">while</span> (e &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[e] == nums[e + <span class="number">1</span>]) e++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;s, e&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end || (start == end &amp;&amp; nums[start] != target)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) <span class="keyword">return</span> binarySearch(nums, start, mid, target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> binarySearch(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-46.png" alt="upload successful"></p><h2 id="35-Search-Insert-Position-easy"><a href="#35-Search-Insert-Position-easy" class="headerlink" title="35. Search Insert Position easy"></a>35. Search Insert Position easy</h2><p>easy 题  没什么好说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchInsertPosition35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().searchInsert(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 问题：Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span></span><br><span class="line"><span class="comment">     * Input: nums = [1,3,5,6], target = 2</span></span><br><span class="line"><span class="comment">     * Output: 1</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 思路：不仅得找到下标，如果没找到还得找到应该插入的下标，二分法，直到start==end的时候判断 target&lt;=nums[start]的话 返回start，否则返回 start-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> doBinarySearch(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doBinarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt;= nums[start]) <span class="keyword">return</span> start;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> start + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) <span class="keyword">return</span> doBinarySearch(nums, start, mid, target);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> doBinarySearch(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;leet-code-每日三道题-01-array-binary-search&quot;&gt;&lt;a href=&quot;#leet-code-每日三道题-01-array-binary-search&quot; class=&quot;headerlink&quot; title=&quot;leet code 每日三道题 01 array+binary search&quot;&gt;&lt;/a&gt;leet code 每日三道题 01 array+binary search&lt;/h1&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://example.com/tags/LeetCode/"/>
    
    <category term="Array" scheme="http://example.com/tags/Array/"/>
    
    <category term="BinarySearch" scheme="http://example.com/tags/BinarySearch/"/>
    
  </entry>
  
  <entry>
    <title>Java 工程师之路 五</title>
    <link href="http://example.com/2021/03/24/Java-%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B9%8B%E8%B7%AF-%E4%BA%94/"/>
    <id>http://example.com/2021/03/24/Java-%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B9%8B%E8%B7%AF-%E4%BA%94/</id>
    <published>2021-03-24T16:34:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><span id="more"></span><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发：即OS中学到的分时操作系统，单cpu采取不同的cpu调度算法也可以让不同任务”同时”进行。</p><p>并行：两个CPU同时执行进程</p><p>进程切换的原理请看OS篇</p><p>进程是OS分配资源的基本单位，线程是基本执行单位。同一进程下的不同线程共享进程资源。</p><p>JVM就是一个进程，多个线程共享JVM资源。且多个线程可以并发执行。</p><h2 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h2><h3 id="线程实体"><a href="#线程实体" class="headerlink" title="线程实体"></a>线程实体</h3><p>线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。 线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。TCB包括以下信息： （1）线程状态。 （2）当线程不运行时，被保存的现场资源。 （3）一组执行堆栈。 （4）存放每个线程的局部变量主存区。 （5）访问同一个进程中的主存和其它资源。 用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><p>在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的地址空间（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p><h2 id="线程实现模型"><a href="#线程实现模型" class="headerlink" title="线程实现模型"></a>线程实现模型</h2><p>即OS中的线程模型概念，内核与用户级线程的对应关系。</p><h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><p>内核线程即OS内核支持的线程，这种线程切换是由OS来操作的。OS通过调度器对线程进行调度，将线程的任务映射到各个CPU上。每个内核线程可以视为内核的分身，支持多线程的内核就叫多线程内核。</p><p>程序一般不适用内核线程，而是用内核线程的一种高级接口：轻量级进程（也就是我们通常指的线程），通常一个内核线程对应一个轻量级进程1：1的情况叫做一对一线程模型。</p><p><img src="/images/pasted-40.png" alt="upload successful"></p><p>由于内核线程的支持，即使有一个轻量级进程被阻塞了，也不会影响整个进程。但缺点是：使用内核线程实现轻量级线程导致各种线程操作（创建，同步）会用到系统调用，需要从用户态切换到内核态，浪费资源，且一个轻量级进程都需要一个内核线程支持，数量有限。</p><h3 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h3><p>广义上：如果一个线程只要不是内核线程都可以认为是用户线程</p><p>侠义上：用户线程完全建立在用户空间的线程库，系统内核无法感知线程的存在，线程的操作都在用户态，这种1：N的关系叫做一对多线程模型。</p><p>使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑的问题，而且由于操作系统只把处理器资源分配到进程，那诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至不可能完成。因而使用用户线程实现的程序一般都比较复杂 ，除了以前在不支持多线程的操作系统中（如DOS）的多线程程序与少数有特殊需求的程序外，现在使用用户线程的程序越来越少了，Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。</p><h3 id="内核线程和用户线程的混合实现"><a href="#内核线程和用户线程的混合实现" class="headerlink" title="内核线程和用户线程的混合实现"></a>内核线程和用户线程的混合实现</h3><p>线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系，如图12-5所示，这种就是多对多的线程模型。</p><p>许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了N：M的线程模型实现。</p><p><img src="/images/pasted-41.png" alt="upload successful"></p><h3 id="线程的6态转换"><a href="#线程的6态转换" class="headerlink" title="线程的6态转换"></a>线程的6态转换</h3><p>具体看OS篇</p><h3 id="Java设置线程优先级"><a href="#Java设置线程优先级" class="headerlink" title="Java设置线程优先级"></a>Java设置线程优先级</h3><p>Java虚拟机采用抢占式调度模型。也就是说他会给优先级更高的线程优先分配CPU。</p><p>虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。</p><p>Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p><p>Java 线程优先级使用 1 ~ 10 的整数表示。默认的优先级是5。</p><blockquote><p>最低优先级 1：Thread.MIN_PRIORITY</p></blockquote><blockquote><p>最高优先级 10：Thread.MAX_PRIORITY</p></blockquote><blockquote><p>普通优先级 5：Thread.NORM_PRIORITY</p></blockquote><p>在Java中，可以使用Thread类的setPriority()方法为线程设置了新的优先级。getPriority()方法返回线程的当前优先级。当创建一个线程时，其默认优先级是创建该线程的线程的优先级。</p><p>以下代码演示如何设置和获取线程的优先：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadPriority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread  Priority:&quot;</span> + t.getPriority());</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread(t1) Priority:&quot;</span> + t1.getPriority());</span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread(t1) Priority:&quot;</span> + t1.getPriority());</span><br><span class="line"></span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread  Priority:&quot;</span> + t.getPriority());</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread(t2) Priority:&quot;</span> + t2.getPriority());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change thread t2 priority to minimum</span></span><br><span class="line">        t2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread(t2) Priority:&quot;</span> + t2.getPriority());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中，Java虚拟机启动时，就会通过main方法启动一个线程，JVM就会一直运行下去，直到以下任意一个条件发生：</p><p>调用了exit()方法，并且exit()有权限被正常执行。<br>所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>Linux线程调度</p><p>在Linux中，线程是由进程来实现，线程就是轻量级进程（ lightweight process ），因此在Linux中，线程的调度是按照进程的调度方式来进行调度的，也就是说线程是调度单元。</p><p>Linux这样实现的线程的好处的之一是：线程调度直接使用进程调度就可以了，没必要再搞一个进程内的线程调度器。在Linux中，调度器是基于线程的调度策略（scheduling policy）和静态调度优先级（static scheduling priority）来决定那个线程来运行。</p><p>在Linux中，主要有三种调度策略。分别是：</p><p>SCHED_OTHER 分时调度策略，（默认的）</p><p>SCHED_FIFO 实时调度策略，先到先服务</p><p>SCHED_RR 实时调度策略，时间片轮转</p><p>Windows线程调度：</p><p>Windows 采用基于优先级的、抢占调度算法来调度线程。</p><p>用于处理调度的 Windows 内核部分称为调度程序，Windows 调度程序确保具有最高优先级的线程总是在运行的。由于调度程序选择运行的线程会一直运行，直到被更高优先级的线程所抢占，或终止，或时间片已到，或调用阻塞系统调用（如 I/O）。如果在低优先级线程运行时，更高优先级的实时线程变成就绪，那么低优先级线程就被抢占。这种抢占使得实时线程在需要使用 CPU 时优先得到使用。</p><p>Java线程调度：</p><p>可以看到，不同的操作系统，有不同的线程调度策略。但是，作为一个Java开发人员来说，我们日常开发过程中一般很少关注操作系统层面的东西。</p><p>主要是因为Java程序都是运行在Java虚拟机上面的，而虚拟机帮我们屏蔽了操作系统的差异，所以我们说Java是一个跨平台语言。</p><p>在操作系统中，一个Java程序其实就是一个进程。所以，我们说Java是单进程、多线程的！</p><p>前面关于线程的实现也介绍过，Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的，也就是说，他需要根据不同的操作系统有不同的实现。</p><p>在Java的多线程程序中，为保证所有线程的执行能按照一定的规则执行，JVM实现了一个线程调度器，它定义了线程调度模型，对于CPU运算的分配都进行了规定，按照这些特定的机制为多个线程分配CPU的使用权。</p><p>主要有两种调度模型：协同式线程调度和抢占式调度模型。</p><h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p>协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。</p><h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><p>抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题。</p><p>系统会让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。</p><p>Java虚拟机采用抢占式调度模型。</p><p>虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p><p>不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应。</p><h3 id="debug-多线程代码"><a href="#debug-多线程代码" class="headerlink" title="debug 多线程代码"></a>debug 多线程代码</h3><p>IDEA的断点设置里，右击选择Thread</p><p><img src="/images/pasted-42.png" alt="upload successful"></p><p>执行代码时就会进入每一个线程。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java中有两类线程：UserThread用户线程、DaemonThread守护线程。用户线程执行用户级任务，守护线程就是后台线程，用来执行后台任务，比如GC 垃圾回收器</p><p>这两种线程其实是没有什么区别的，唯一的区别就是Java虚拟机在所有“用户线程”都结束后就会退出。也就是如果JVM只剩下了守护线程那么JVM就会退出。</p><p>我们可以通过使用setDaemon()方法通过传递true作为参数，使线程成为一个守护线程。我们必须在启动线程之前调用一个线程的setDaemon()方法。否则，就会抛出一个java.lang.IllegalThreadStateException。</p><p>可以使用isDaemon()方法来检查线程是否是守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">        System.out.println(t1.isDaemon()); <span class="comment">// false</span></span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(t1.isDaemon());<span class="comment">// true</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.setDaemon(<span class="keyword">false</span>);<span class="comment">// 抛出异常，JVM已退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中设置了子线程为守护线程，所以当代码执行后只有子线程，JVM退出，无法设置。</p><h2 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h2><h3 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h3><p>继承Thread类并且重写run方法即可。注意的是：在主线程中，调用了子线程的Start()方法后，主线程是不会等待而是继续执行。也可以不调用Start()方法而直接调用run方法，这时候的run方法不过是个普通方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般用这个方法，继承的话只能继承一个，接口就无所谓了，两种方式创建的线程没区别基本。</p><p>但是这两种方式创建的线程是无法在执行完后返回值给主线程的。</p><p>如果想要获取子线程的值，要用Callable和FutureTask</p><h3 id="Callable-amp-FutureTask"><a href="#Callable-amp-FutureTask" class="headerlink" title="Callable &amp; FutureTask"></a>Callable &amp; FutureTask</h3><p>这两是JDK1.5之后的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        MyCallableThread myCallableThread = <span class="keyword">new</span> MyCallableThread();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myCallableThread);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallableThread</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;doing something&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my callable thread&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-43.png" alt="upload successful"></p><p>FutureTask可用于异步获取执行结果或取消执行。FutureTask非常适合用于耗时的计算，主线程可以在启动FutureTask后去做其他事，在其余事情做完后调用get方法获取结果。</p><p>调用get方法会阻塞主线程，直到子线程返回值，可以通过isDone()来判断子线程是否执行完成。</p><p>可以改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       CallableThread callableThread = <span class="keyword">new</span> CallableThread();</span><br><span class="line">       FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callableThread);</span><br><span class="line">       <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;主线程先做其他重要的事情&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span>(!futureTask.isDone())&#123;</span><br><span class="line">           <span class="comment">// 继续做其他事儿</span></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(future.get()); <span class="comment">// 可能会阻塞等待结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般会将Callable放入线程池，让线程池执行Callable的代码。手动new Thread(futureTask)还是有开销的。</p><h3 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h3><p>Java提供的线程池创建线程方式，调用ThreadPoolExecutor即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">      executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>线程池本质是个HashSet，多余的任务存入阻塞队列中</p><h4 id="线程池的主要参数"><a href="#线程池的主要参数" class="headerlink" title="线程池的主要参数"></a>线程池的主要参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p><p>2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p><p>3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p><p>4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</p><p>5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p><p>5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p><p>为什么使用阻塞队列：如果是非阻塞队列，需要线程不停判断是否有事件，一直占用CPU资源，不好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;并发编程&quot;&gt;&lt;a href=&quot;#并发编程&quot; class=&quot;headerlink&quot; title=&quot;并发编程&quot;&gt;&lt;/a&gt;并发编程&lt;/h1&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>日语</title>
    <link href="http://example.com/2021/03/23/%E6%97%A5%E8%AF%AD/"/>
    <id>http://example.com/2021/03/23/%E6%97%A5%E8%AF%AD/</id>
    <published>2021-03-23T09:10:00.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h2><span id="more"></span><h3 id="这个是-那个是"><a href="#这个是-那个是" class="headerlink" title="这个是 那个是"></a>这个是 那个是</h3><p>两者沟通情况下：</p><ul><li>これ 离说话人最近的</li><li>それ 离说话人远的</li><li>あれ 离两个说话人都远的</li></ul><p>变为连体次 即：这个xxx，那个xxx</p><ul><li>この</li><li>あの</li><li>その</li></ul><blockquote><blockquote><p>eg: <code>この　カメァわ　スミスさんのです</code> 这个相机是史密斯先生的</p></blockquote></blockquote><h3 id="谁-这是谁的伞"><a href="#谁-这是谁的伞" class="headerlink" title="谁 这是谁的伞"></a>谁 这是谁的伞</h3><p>だれ</p><blockquote><blockquote><p>eg: <code>あれわ　だれの　傘ですか</code> 这是谁的伞</p></blockquote></blockquote><h3 id="表示否定-这不是而是"><a href="#表示否定-这不是而是" class="headerlink" title="表示否定 这不是而是"></a>表示否定 这不是而是</h3><p>いいえ　それわ　ｘｘｘ　ありません．ｘｘｘです</p><p>不这不是xxx 而是xxx</p><blockquote><blockquote><p>日常用法：直接回答　それわ　ｘｘｘです</p></blockquote></blockquote><h3 id="哪个-我的包是哪个？"><a href="#哪个-我的包是哪个？" class="headerlink" title="哪个  我的包是哪个？"></a>哪个  我的包是哪个？</h3><p>多个物体选一个 至少三个才能用，如果是两个里面选：どちら</p><p>どれ</p><p>eg: <code>森さんの　かばんわ　どれですか</code>　森先生的包是哪个</p><p>eg: <code>その　ノートわ　だれのですか</code>　那个笔是谁的</p><h3 id="敬语"><a href="#敬语" class="headerlink" title="敬语"></a>敬语</h3><p>那个人：　このひど</p><p>那位敬语：このかた</p><p>谁：だれ</p><p>谁（敬语）：どなた</p><h3 id="多大年纪"><a href="#多大年纪" class="headerlink" title="多大年纪"></a>多大年纪</h3><p>多大年纪：いくつ</p><p>美化语： おいくつ</p><p>问小孩：なんさい</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第二课&quot;&gt;&lt;a href=&quot;#第二课&quot; class=&quot;headerlink&quot; title=&quot;第二课&quot;&gt;&lt;/a&gt;第二课&lt;/h2&gt;</summary>
    
    
    
    <category term="日语" scheme="http://example.com/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
    <category term="日语" scheme="http://example.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>socketio实时推送</title>
    <link href="http://example.com/2021/03/17/socketio%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81/"/>
    <id>http://example.com/2021/03/17/socketio%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81/</id>
    <published>2021-03-17T10:55:58.000Z</published>
    <updated>2022-01-19T04:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socketio-实时推送"><a href="#socketio-实时推送" class="headerlink" title="socketio 实时推送"></a>socketio 实时推送</h1><p>不仅是简单的建立连接响应，还要每隔一段时间推送数据到客户端</p><span id="more"></span><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.corundumstudio.socketio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-socketio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.56<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="yml-配置"><a href="#yml-配置" class="headerlink" title="yml 配置"></a>yml 配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">socketio:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9922</span><span class="comment">#监听端口</span></span><br><span class="line">  <span class="comment"># host: 127.0.0.1#监听的ip</span></span><br><span class="line">  <span class="comment"># 设置最大每帧处理数据的长度，防止他人利用大数据来攻击服务器</span></span><br><span class="line">  <span class="comment"># maxFramePayloadLength: 1048576</span></span><br><span class="line">  <span class="comment"># 设置http交互最大内容长度</span></span><br><span class="line">  <span class="comment"># maxHttpContentLength: 1048576</span></span><br><span class="line">  <span class="comment"># socket连接数大小（如只监听一个端口boss线程组为1即可）</span></span><br><span class="line">  <span class="comment"># bossCount: 1</span></span><br><span class="line">  <span class="comment"># workCount: 100</span></span><br><span class="line">  <span class="comment"># allowCustomRequests: true</span></span><br><span class="line">  <span class="comment"># 协议升级超时时间（毫秒），默认10秒。HTTP握手升级为ws协议超时时间</span></span><br><span class="line">  <span class="comment"># upgradeTimeout: 1000000</span></span><br><span class="line">  <span class="comment"># Ping消息超时时间（毫秒），默认60秒，这个时间间隔内没有接收到心跳消息就会发送超时事件</span></span><br><span class="line">  <span class="comment"># pingTimeout: 6000000</span></span><br><span class="line">  <span class="comment"># Ping消息间隔（毫秒），默认25秒。客户端向服务器发送一条心跳消息间隔</span></span><br><span class="line">  <span class="comment"># pingInterval: 25000</span></span><br></pre></td></tr></table></figure><h2 id="socketio-配置"><a href="#socketio-配置" class="headerlink" title="socketio 配置"></a>socketio 配置</h2><p>@Configuration 和 @Bean 将spring管理的socketIOServer配置为我们自定义的server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cc.crrc.manage.mq.RabbitmqChannelListener;</span><br><span class="line"><span class="keyword">import</span> com.corundumstudio.socketio.SocketIOClient;</span><br><span class="line"><span class="keyword">import</span> com.corundumstudio.socketio.SocketIOServer;</span><br><span class="line"><span class="keyword">import</span> com.corundumstudio.socketio.listener.ExceptionListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIOConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;socketio.port:&#x27;&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> socketIOPort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketIOConfiguration.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;socketIOServer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        com.corundumstudio.socketio.Configuration configuration = <span class="keyword">new</span> com.corundumstudio.socketio.Configuration();</span><br><span class="line">        configuration.setPort(socketIOPort);</span><br><span class="line">        configuration.setExceptionListener(<span class="keyword">new</span> ExceptionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventException</span><span class="params">(Exception e, List&lt;Object&gt; list, SocketIOClient socketIOClient)</span> </span>&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;客户端:&quot;</span> + socketIOClient.getRemoteAddress() + <span class="string">&quot; EventException：&quot;</span> +e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnectException</span><span class="params">(Exception e, SocketIOClient socketIOClient)</span> </span>&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;客户端:&quot;</span> + socketIOClient.getRemoteAddress() + <span class="string">&quot; DisconnectException：&quot;</span> +e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectException</span><span class="params">(Exception e, SocketIOClient socketIOClient)</span> </span>&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;客户端:&quot;</span> + socketIOClient.getRemoteAddress() + <span class="string">&quot; ConnectException：&quot;</span> +e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPingException</span><span class="params">(Exception e, SocketIOClient socketIOClient)</span> </span>&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;客户端:&quot;</span> + socketIOClient.getRemoteAddress() + <span class="string">&quot; PingException：&quot;</span> +e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext channelHandlerContext, Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        configuration.setOrigin(&quot;*&quot;);</span></span><br><span class="line"><span class="comment">//        configuration.setSocketConfig();</span></span><br><span class="line"><span class="comment">//        configuration.setWorkerThreads(1);</span></span><br><span class="line"><span class="comment">//         configuration.setAllowCustomRequests(true);</span></span><br><span class="line"><span class="comment">//        configuration.setUpgradeTimeout(10000);</span></span><br><span class="line"><span class="comment">//        configuration.setPingTimeout(60000);</span></span><br><span class="line"><span class="comment">//        configuration.setPingInterval(25000);</span></span><br><span class="line"><span class="comment">//        configuration.setMaxHttpContentLength(2071738);</span></span><br><span class="line"><span class="comment">//        configuration.setMaxFramePayloadLength(2071738);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SocketIOServer(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>configuration.setExceptionListener(new ExceptionListener() &#123;...</code>可以不用写 这里只是重写了异常监听，用于记录日志到系统。</p><h2 id="定义线程处理接口"><a href="#定义线程处理接口" class="headerlink" title="定义线程处理接口"></a>定义线程处理接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MonitorProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现线程处理接口"><a href="#实现线程处理接口" class="headerlink" title="实现线程处理接口"></a>实现线程处理接口</h2><p>处理传递过来的message 产生返回消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GPSProcessor</span> <span class="keyword">implements</span> <span class="title">MonitorProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GPSProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MtrVehicleService vehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;tr&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射主题和处理类"><a href="#映射主题和处理类" class="headerlink" title="映射主题和处理类"></a>映射主题和处理类</h2><p>将所有类根据名字存入map中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SocketRoute</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LINE_MONITOR(<span class="string">&quot;lineMonitor&quot;</span>, <span class="string">&quot;/line&quot;</span>, LineMonitorProcessor.class, <span class="number">2000</span>),</span><br><span class="line">    VEHICLE_MONITOR(<span class="string">&quot;trainMonitor&quot;</span>, <span class="string">&quot;/vehicle&quot;</span>, VehicleMonitorProcessor.class, <span class="number">1000</span>),</span><br><span class="line">    VEHICLE_GPS(<span class="string">&quot;GPSMonitor&quot;</span>, <span class="string">&quot;/gps&quot;</span>, GPSProcessor.class, <span class="number">2000</span>),</span><br><span class="line">    VEHICLE_FAULT(<span class="string">&quot;faultInform&quot;</span>, <span class="string">&quot;/fault&quot;</span>, GlobalFaultInformProcessor.class, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, SocketRoute&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SocketRoute route : SocketRoute.values()) &#123;</span><br><span class="line">            routes.put(route.getCmd(),route);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends MonitorProcessor&gt; monitorClass;</span><br><span class="line">    <span class="keyword">private</span> String nameSpace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> intervalTime;</span><br><span class="line">    <span class="keyword">private</span> String cmd;</span><br><span class="line"></span><br><span class="line">    SocketRoute(String cmd, String nameSpace, Class&lt;? extends MonitorProcessor&gt; monitorClass, <span class="keyword">int</span> intervalTime) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">        <span class="keyword">this</span>.nameSpace = nameSpace;</span><br><span class="line">        <span class="keyword">this</span>.monitorClass = monitorClass;</span><br><span class="line">        <span class="keyword">this</span>.intervalTime = intervalTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends MonitorProcessor&gt; getMonitorClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> monitorClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNameSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nameSpace;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIntervalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intervalTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCmd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> SocketRoute <span class="title">getSocketRoute</span><span class="params">(String cmd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> routes.get(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建server"><a href="#创建server" class="headerlink" title="创建server"></a>创建server</h2><p>配置socketIOServer启动类，并且在spring容器初始化后启动，有两种方式实现自动启动 </p><ol><li><p>实现CommandLineRunner接口 实现里面的run方法</p></li><li><p>@PostConstruct标签描述方法，被描述的方法会自动在构建后执行</p></li><li><p>以下这种实现是多线程共享一个socket通道，如果数据量大还是和前端建立多个通道好。</p></li></ol><p>前端后端约定监听<code>talk</code>事件，且发送的json内容的两个key分别为<code>cmd</code>和<code>message</code>，定义一个SocketRoute的enum 保存不同cmd的处理事件和间隔时间。假设发送的json为<code>&#123;&quot;cmd&quot;:&quot;GPSMonitor&quot;,&quot;message&quot;:&#123;&quot;vehicle&quot;:&quot;t&quot;&#125;&#125;</code>，通过枚举类找到 GPSMonitor为key的值的类，将该类的对象作为线程的内部对象，启动新的线程，首先根据key取消之前的线程，再重写启动新的线程，内部调用传递类的process方法。</p><p>处理线程内部根据是否循环loop和循环间隔interval 不停调用处理对象的process方法和<code>socketIOClient.sendEvent(&quot;message&quot;, returnVal);</code>返回客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIOStartup</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketIOStartup.class);</span><br><span class="line">    <span class="comment">// 保存当前运行的socket线程 一个key一个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, SocketThread&gt; socketThreadMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SocketIOServer socketIOServer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startUpServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bindListener();</span><br><span class="line">        socketIOServer.startAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        connect();</span><br><span class="line">        disconnect();</span><br><span class="line">        bindEventListener();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 可以不写，这里重写connect的监听方法用于日志记录</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        socketIOServer.addConnectListener(<span class="keyword">new</span> ConnectListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnect</span><span class="params">(SocketIOClient socketIOClient)</span> </span>&#123;</span><br><span class="line">                logger.info(<span class="string">&quot;&#123;&#125;已连接&quot;</span>, socketIOClient.getRemoteAddress().toString() + socketIOClient.getSessionId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 可以不写，这里重写disconnect的监听方法用于日志记录</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        socketIOServer.addDisconnectListener(<span class="keyword">new</span> DisconnectListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnect</span><span class="params">(SocketIOClient socketIOClient)</span> </span>&#123;</span><br><span class="line">                SocketThread st = socketThreadMap.get(socketIOClient.getSessionId().toString());</span><br><span class="line">                <span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    st.setLoop(<span class="keyword">false</span>);</span><br><span class="line">                    socketThreadMap.remove(socketIOClient.getSessionId().toString());</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">&quot;&#123;&#125;已关闭&quot;</span>, socketIOClient.getSessionId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 绑定监听事件：cmd 实现监听方法 前端也要发送该事件才能调用这个方法：socket.emit(&quot;cmd&quot;..</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        socketIOServer.addEventListener(<span class="string">&quot;talk&quot;</span>, Object.class, <span class="keyword">new</span> DataListener&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(SocketIOClient socketIOClient, Object value, AckRequest ackRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                sendMessage(socketIOClient, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 消息处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(SocketIOClient socketIOClient, Object object)</span> <span class="keyword">throws</span> JsonParseException </span>&#123;</span><br><span class="line">        String cmd;</span><br><span class="line">        String value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String jsonString = JSONObject.toJSONString(object);</span><br><span class="line">            JSONObject cmdJson = JSONObject.parseObject(jsonString);</span><br><span class="line">            cmd = cmdJson.getString(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            value = cmdJson.getString(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RestApiException(ExceptionInfoEnum.DATA_PARSE_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        &#125; else &#123;</span></span><br><span class="line"><span class="comment">//            throw new RestApiException(ExceptionInfoEnum.URL_PARAMETER_MISMATCH_EXCEPTION);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//得到处理类</span></span><br><span class="line">        SocketRoute route = SocketRoute.getSocketRoute(cmd);</span><br><span class="line">        <span class="keyword">if</span> (route == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;找不到该cmd:&quot;</span> + cmd + <span class="string">&quot; 对应的处理方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MonitorProcessor processor = SpringBeanUtils.getBean(route.getMonitorClass());</span><br><span class="line">        <span class="comment">// 将该处理类作为包装成线程启动</span></span><br><span class="line">        startThread(socketIOClient, processor, value, route.getIntervalTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(SocketIOClient socketIOClient, MonitorProcessor processor, String value, <span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">        SocketThread st = socketThreadMap.get(socketIOClient.getSessionId().toString());</span><br><span class="line">        <span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">            st.setLoop(<span class="keyword">false</span>);</span><br><span class="line">            socketThreadMap.remove(socketIOClient.getSessionId().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        SocketThread st_new = <span class="keyword">new</span> SocketThread(socketIOClient, processor, value, interval);</span><br><span class="line">        socketThreadMap.put(socketIOClient.getSessionId().toString(), st_new);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(st_new);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SocketThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SocketIOClient socketIOClient;</span><br><span class="line">        <span class="keyword">private</span> MonitorProcessor processor;</span><br><span class="line">        <span class="keyword">private</span> String value;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> interval;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SocketThread</span><span class="params">(SocketIOClient socketIOClient, MonitorProcessor processor, String value, <span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socketIOClient = socketIOClient;</span><br><span class="line">            <span class="keyword">this</span>.processor = processor;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoop</span><span class="params">(<span class="keyword">boolean</span> loop)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.loop = loop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (loop &amp;&amp; socketIOClient.isChannelOpen()) &#123;</span><br><span class="line">                Object returnVal = processor.process(value);</span><br><span class="line">                <span class="keyword">if</span> (loop &amp;&amp; socketIOClient.isChannelOpen()) &#123;</span><br><span class="line">                    socketIOClient.sendEvent(<span class="string">&quot;message&quot;</span>, returnVal);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(interval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Socket clientId:&#123;&#125; &#123;&#125;&quot;</span>, socketIOClient.getSessionId(), e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        startUpServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前端测试"><a href="#前端测试" class="headerlink" title="前端测试"></a>前端测试</h2><p>npm install socketio</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;script src=&quot;/js/socketio/socket.io.js&quot;&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.3.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> first = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">         <span class="keyword">var</span> socket ;</span></span><br><span class="line"><span class="javascript">           $(<span class="string">&quot;#connectBtn&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(first)&#123;</span></span><br><span class="line"><span class="javascript">                socket = io.connect(<span class="string">&#x27;http://localhost:9922&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                 <span class="built_in">console</span>.log(socket)</span></span><br><span class="line"><span class="javascript">                socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">&quot;#content&quot;</span>).text(<span class="string">&quot;连接成功&quot;</span>)</span></span><br><span class="line"><span class="javascript">                &#125;);</span></span><br><span class="line"><span class="javascript">                 socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                   $(<span class="string">&quot;#content&quot;</span>).text(<span class="string">&quot;连接断开&quot;</span>)</span></span><br><span class="line"><span class="javascript">                &#125;);</span></span><br><span class="line"><span class="javascript">                socket.on(<span class="string">&quot;message&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">&quot;#content&quot;</span>).text(data);</span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">                first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">                &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    socket.connect();</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">           &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">           $(<span class="string">&quot;#cancelBtn&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                socket.disconnect();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(socket);</span></span><br><span class="line"><span class="javascript">           &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">           $(<span class="string">&quot;#sendBtn&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                socket.emit(<span class="string">&quot;cmd&quot;</span>,<span class="built_in">JSON</span>.parse($(<span class="string">&quot;#message&quot;</span>).val()));</span></span><br><span class="line"><span class="javascript">           &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;connectBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;连接&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cancelBtn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>断开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;socketio-实时推送&quot;&gt;&lt;a href=&quot;#socketio-实时推送&quot; class=&quot;headerlink&quot; title=&quot;socketio 实时推送&quot;&gt;&lt;/a&gt;socketio 实时推送&lt;/h1&gt;&lt;p&gt;不仅是简单的建立连接响应，还要每隔一段时间推送数据到客户端&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
